[{"title":"golang基础","date":"2020-02-23T09:10:01.000Z","path":"2020/02/23/golang/golang基础/","text":"指针、取址、和值123var v = 1 // v 保存的是值1ptr := &amp;v // ptr保存的是v的内存地址(0x000AF)p := *ptr // p和v相等 声明变量和实例化对象的几种方式 var、new、make var 用于定义一个变量，且为它分配零zhi返回的是对象本身， new返回的是对象的引用， make 实例化结构体的几种方法 12345678910111213141516type TypeA struct &#123; Name string&#125;vaule := TypeA&#123;&#125; // 实例化一个对象addr1 := &amp;TypeA&#123;&#125; // 返回对象的地址addr2 := new(TypeA) // new操作符返回的是新对象的引用地址var a * Model // 未初始化，a是指向model的指针类型make(map[string]string) // map 和 数组 不make的话，会得到nil，无法使用其方法注意：变量在使用前最好初始化 函数结构体方法 Go 没有类。 不过你可以为结构体类型定义方法。 方法就是一类带特殊的 接收者 参数的函数。 方法接收者在它自己的参数列表内，位于 func 关键字和方法名之间。 方法只是个带接收者参数的函数。 只能为在同一包内定义的类型的接收者声明方法，而不能为其它包内定义的类型（包括 int 之类的内建类型）的接收者声明方法。 （译注：就是接收者的类型定义和方法声明必须在同一包内；不能为内建类型声明方法。） 123456789101112type Vertex struct &#123; X, Y float64&#125;func (v Vertex) Abs() float64 &#123; return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;func main() &#123; v := Vertex&#123;3, 4&#125; fmt.Println(v.Abs())&#125; 与下面的方法在功能上没有区别 123456789101112type Vertex struct &#123; X, Y float64&#125;func Abs(v Vertex) float64 &#123; return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;func main() &#123; v := Vertex&#123;3, 4&#125; fmt.Println(Abs(v))&#125; 结构体可以有方法指针类型的接收者你可以为指针接收者声明方法。 这意味着对于某类型 T，接收者的类型可以用 T 的文法。（此外，T 不能是像 int 这样的指针。） 指针接收者的方法可以修改接收者指向的值（就像 Scale 在这做的）。由于方法经常需要修改它的接收者，指针接收者比值接收者更常用。 若使用值接收者，那么 Scale 方法会对原始 Vertex 值的副本进行操作。（对于函数的其它参数也是如此。）Scale 方法必须用指针接受者来更改 main 函数中声明的 Vertex 的值。 1234567891011121314151617181920212223242526272829package mainimport ( &quot;fmt&quot; //&quot;math&quot;)type Vertex struct &#123; X, Y float64&#125;func (v Vertex) Abs() int32 &#123; //return math.Sqrt(v.X*v.X + v.Y*v.Y) v.X = 1 v.Y =10 fmt.Println(v) // &#123;1, 10&#125; return 0&#125;func (v *Vertex) Scale(f float64) &#123; v.X = v.X * f v.Y = v.Y * f&#125;func main() &#123; v := Vertex&#123;3, 4&#125; //v.Scale(10) // fmt.Println(v.Abs(), v) // v: &#123;3, 4&#125;&#125; 使用结构体的时候，注意值传递和引用传递的区别 带指针参数的函数必须接受一个指针： 12345678910111213141516171819202122232425type Vertex struct &#123; X, Y float64&#125;func (v *Vertex) Scale(f float64) &#123; v.X = v.X * f v.Y = v.Y * f&#125;func ScaleFunc(v *Vertex, f float64) &#123; v.X = v.X * f v.Y = v.Y * f&#125;func main() &#123; v := Vertex&#123;3, 4&#125; v.Scale(2) ScaleFunc(&amp;v, 10) p := &amp;Vertex&#123;4, 3&#125; p.Scale(3) ScaleFunc(p, 8) fmt.Println(v, p)&#125; 比较前两个程序，你大概会注意到带指针参数的函数必须接受一个指针： 123var v VertexScaleFunc(v, 5) // 编译错误！ScaleFunc(&amp;v, 5) // OK 而以指针为接收者的方法被调用时，接收者既能为值又能为指针： 1234var v Vertexv.Scale(5) // OKp := &amp;vp.Scale(10) // OK 对于语句 v.Scale(5)，即便 v 是个值而非指针，带指针接收者的方法也能被直接调用。 也就是说，由于 Scale 方法有一个指针接收者，为方便起见，Go 会将语句 v.Scale(5) 解释为 (&amp;v).Scale(5)。 数组for 循环的 range 形式可遍历切片或映射。 当使用 for 循环遍历切片时，每次迭代都会返回两个值。第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本。 1234567var pow = []int&#123;1, 2, 4, 8, 16, 32, 64, 128&#125;func main() &#123; for i, v := range pow &#123; fmt.Printf(&quot;2**%d = %d\\n&quot;, i, v) &#125;&#125; range（续）可以将下标或值赋予 _ 来忽略它。 for i, _ := range powfor _, value := range pow若你只需要索引，忽略第二个变量即可。 for i := range pow","tags":[{"name":"golang基础","slug":"golang基础","permalink":"http://yoursite.com/tags/golang基础/"}]},{"title":"Git 常用操作","date":"2020-02-23T07:06:01.000Z","path":"2020/02/23/杂项/Git常用操作/","text":"引言git 的命令有很多，全部都掌握的话比较困难，但根据二八定理，我们只需要熟练掌握一些常用的操作即可满足日常工作所需，以下列举了一些常用场景下的解决方案。 关于 git add 慎用 git add . 它表示把当前工作区的改动全部添加 trace，很有可能就会把一些无关文件加进去，一旦 commit -&gt; push 就会到远程分支。因此，在执行 git add 之前，最好先 git status 康一下目前的改动状态，确认可以用的时候再用。 如果不小心使用了它，并且加入了一些不想要的文件，此时该怎么办呢？ 如果还未进行 commit: 可以使用 git checkout 文件 [-r 目录] 将其还原 如果已经 commit: 可以使用 git rm --cached 文件，将其从暂存区移除，如果需要还原改动，再使用 git checkout 文件。 关于 git checkout git checkout [-q] [commit id] [–] 该命令主要用于检出某一个指定文件。 如果不填写commit id，则默认会从暂存区检出该文件，如果暂存区为空，则该文件会回滚到最近一次的提交状态。当暂存区为空，如果我们想要放弃对某一个文件的修改，可以用这个命令进行撤销： 如果填写commit id（既可以是commit hash也可以是分支名称还可以说tag，其本质上都是commit hash），则会从指定commit hash中检出该文件。用于恢复某一个文件到某一个提交状态。 git checkout -b new-branch origin/new-branch 项目从远程拉下来后，本地只有一个 master 分支，该命令用于在本地新建一个远程分支的拷贝。 关于 git rm git rm -r –cached file //不删除本地文件，只是移除暂存区 git rm -r –f file //删除并移除暂存区 关于 git push大多数情况下，我们都是使用这个命令的简写： git push orign xxbranch，它的完整形式为： git push 远程名 本地分支名:远程分支名 所以，以下等价： 123git push git push 默认远程 当前分支:远程同名分支 关于分支关联给一个项目的本地分支关联到远程对应分支（设定默认trace），此后可以直接使用 git pull/push 等简写： 1官方释义： Branch &apos;dev_wangdian&apos; set up to track remote branch &apos;dev_wangdian&apos; from &apos;origin&apos;. git branch –set-upstream-to=origin/branch1 本地branch1 可以在推送的时候同时设置 track： git push -u 远程名 本地分支名 关于删除分支要想删除一个远程分支，可以通过把 当前分支 设为空，即： git push origin :远程待删除分支 补充一个删除本地分支的命令： git branch -d (branchname) 配置 gitbash 为中文 git config –global core.quotepath false","tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"react新特性","date":"2019-10-01T03:39:01.000Z","path":"2019/10/01/React相关/React新特性/","text":"Hooks1. State Hook即在函数组件中创建 state 和与之搭配的 setState() 方法 用法： let [someProps, setSomeProps] = useState(initData) 当跟视图相关的数据发生了变化时，可以有如下两种方式触发 UI 重新渲染： 把新值作为参数传给 setSomeProps 方法。 传递一个函数给 setSomeProps 方法，该函数接收一个 oldVlaue 入参。 2. Effect Hook在 React 组件中执行数据获取、订阅或者手动修改过 DOM 这些操作称为“副作用”。Effect Hook 可以让你在函数组件中执行副作用操作。 useEffect 就是一个 Effect Hook，给函数组件增加了操作副作用的能力。它跟 class 组件 中的 componentDidMount、componentDidUpdate 和 componentWillUnmount 具有相同的用途，只不过被合并成了一个 API。 effects会在每次渲染后运行，并且概念上它是组件输出的一部分，可以“看到”属于某次特定渲染的 props 和 state。 实际上每一个组件内的函数（包括事件处理函数，effects，定时器或者 API 调用等等）会通过闭包来捕获某次渲染中定义的 props 和 state。在组件内什么时候去读取 props 或者 state 是无关紧要的。因为它们不会改变，在单次渲染的范围内，props 和 state 始终保持不变。（解构赋值的props使得这一点更明显。） 如何避免Capture Value，使得取到的数据为最新？场景：有时候你可能想在effect的回调函数里读取最新的值而不是捕获的值。最简单的实现方法是使用 refs: 利用 useRef 就可以绕过 Capture Value 的特性。可以认为 ref 在所有 Render 过程中保持着唯一引用，因此所有对 ref 的赋值或取值，拿到的都只有一个最终状态，而不会在每个 Render 间存在隔离。 1234567891011121314function Example() &#123; const [count, setCount] = useState(0); const latestCount = useRef(count); useEffect(() =&gt; &#123; // Set the mutable latest value latestCount.current = count; setTimeout(() =&gt; &#123; // Read the mutable latest value console.log(`You clicked $&#123;latestCount.current&#125; times`); &#125;, 3000); &#125;); // ...&#125; 也可以简洁的认为，ref 是 Mutable 的，而 state 是 Immutable 的。 useEffect用法1：在每次UI更新后，调用effect操作副作用 useEffect(cb) 12345//cb() =&gt; &#123; //some operations // ...&#125; useEffect用法2：做一些副作用的清除操作1234567// 如果需要在下一次渲染（包括组件被销毁）时，想让通过 useEffect 注册的副作用被销毁，这一点可以通过 useEffect 的返回值做到：useEffect(() =&gt; &#123; ChatAPI.subscribeToFriendStatus(props.id, handleStatusChange); return () =&gt; &#123; ChatAPI.unsubscribeFromFriendStatus(props.id, handleStatusChange); &#125;;&#125;); 一般来说： 在下一次绘制完成之后、 effect 执行之前，执行清理工作，并且被清理的内容属于上次渲染。 假设第一次渲染的时候props是{id: 10}，第二次渲染的时候是{id: 20}，则有： React 渲染{id: 20}的UI。 浏览器绘制。我们在屏幕上看到{id: 20}的UI。 React 清除{id: 10}的effect。 React 运行{id: 20}的effect。 useEffect用法3：在不需要的时候避免调用effect useEffect(cb, [deps]) React并不能猜测到函数做了什么如果不先调用的话，因此 React 无法区分 effects 的不同。如果想要避免effects不必要的重复调用，你可以提供给useEffect一个依赖数组参数(deps)，通知 React 仅仅当在 deps里面的数据发生变化时调用 effects。 注意：当 deps 为一个空数组的时候，effects 仅仅在首次挂载的时候得到执行 两种告知依赖的策略：（可结合使用） 第一种策略是在依赖中包含所有effect中用到的组件内的值。 1234// 例如：useEffect(()=&gt;&#123; setSomePorps(count + 1)&#125;, [count]) 第二种策略是修改effect内部的代码以确保它包含的值只会在需要的时候发生变更。一般配合 setSomeProps((oldValue)=&gt;{...}) 来使用。 123456// 例如：useEffect(()=&gt;&#123; setInterval(()=&gt;&#123; setSomePorps(oldValue =&gt; oldVlaue + 1) &#125;,3000)&#125;, []) 参考： useEffect 完整指南 精读《useEffect 完全指南》 3. ContextHooksContext API是React提供的一种跨节点数据访问的方式。context 很早就有，只是不好用，源自 redux 的灵感，react 从 v16.3 之后推出了全新的版本。 用法： useContext() 1234567891011121314151617181920212223242526272829303132333435363738const CountContext = React.createContext();const CountProvider = (&#123; children &#125;) =&gt; &#123; const contextValue = useReducer(reducer, initialState); return ( &lt;CountContext.Provider value=&#123;contextValue&#125;&gt; &#123;children&#125; &lt;/CountContext.Provider&gt; );&#125;;// some v-dom&lt;&gt; &lt;CountProvider&gt; &lt;Counter /&gt; &lt;/CountProvider&gt; &lt;CountProvider&gt; &lt;Counter /&gt; &lt;/CountProvider&gt; &lt;/&gt; // counterconst useCount = () =&gt; &#123; const contextValue = useContext(CountContext); return contextValue;&#125;;const Counter = () =&gt; &#123; const [count, dispatch] = useCount(); return ( &lt;div&gt; &#123;count&#125; &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: \"increment\" &#125;)&#125;&gt;+1&lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: \"decrement\" &#125;)&#125;&gt;-1&lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: \"set\", count: 0 &#125;)&#125;&gt;reset&lt;/button&gt; &lt;/div&gt; );&#125;; 4. useReducer用法一（常规用法，单纯操作state）： const [state, dispatch] = useReducer(reducer, initialState); reducer可以让你把组件内发生了什么(actions)和状态如何响应并更新分开表述。即可用于解耦用户行为和状态管理。 effect不再关心怎么更新状态，它只负责告诉我们发生了什么。更新的逻辑全都交由reducer去统一处理: 1234567891011121314151617// someReducer.jsconst initialState = &#123; count: 0, step: 1,&#125;;// 一般情况下，reducer只能操作statefunction reducer(state, action) &#123; const &#123; count, step &#125; = state; if (action.type === 'tick') &#123; return &#123; count: count + step, step &#125;; &#125; else if (action.type === 'step') &#123; return &#123; count, step: action.step &#125;; &#125; else &#123; throw new Error(); &#125;&#125; React会保证dispatch在组件的声明周期内保持不变。因此，可以使用 useReducer 来精简依赖。 123456789const [state, dispatch] = useReducer(reducer, initialState);const &#123; count, step &#125; = state;useEffect(() =&gt; &#123; const id = setInterval(() =&gt; &#123; dispatch(&#123; type: 'tick' &#125;); // Instead of setCount(c =&gt; c + step); &#125;, 1000); return () =&gt; clearInterval(id);&#125;, []); //写成 [dispatch] 也 ok 注：可以从依赖中去除 dispatch, setState, 和 useRef 包裹的值因为 React 会确保它们是静态的。不过设置了它们作为依赖也没什么问题。 用法二（特殊用法，操作 state 和 props）：1234567891011121314151617181920function Counter(&#123; step &#125;) &#123; const [count, dispatch] = useReducer(reducer, 0); function reducer(state, action) &#123; if (action.type === 'tick') &#123; return state + step; &#125; else &#123; throw new Error(); &#125; &#125; useEffect(() =&gt; &#123; const id = setInterval(() =&gt; &#123; dispatch(&#123; type: 'tick' &#125;); &#125;, 1000); return () =&gt; clearInterval(id); &#125;, [dispatch]); return &lt;h1&gt;&#123;count&#125;&lt;/h1&gt;;&#125; 如上所示代码，当把 reducers 放到组件内部时，就可以访问到 props 了。 tips： 可以把跟 effect 相关的函数都写在 effect 内部，这样便于精准的书写依赖 可以把函数作为依赖，此时该函数是可变的，它的描述使用 useCallback(func, [deps]) 12345678910111213141516171819202122//对于通过属性从父组件传入的函数适用：function Parent() &#123; const [query, setQuery] = useState('react'); // ✅ Preserves identity until query changes const fetchData = useCallback(() =&gt; &#123; const url = 'https://hn.algolia.com/api/v1/search?query=' + query; // ... Fetch data and return it ... &#125;, [query]); // ✅ Callback deps are OK return &lt;Child fetchData=&#123;fetchData&#125; /&gt;&#125;function Child(&#123; fetchData &#125;) &#123; let [data, setData] = useState(null); useEffect(() =&gt; &#123; fetchData().then(setData); &#125;, [fetchData]); // ✅ Effect deps are OK // ...&#125; 5. 自定义hooks自定义 Hook 是一个函数，其名称以 “use” 开头，函数内部可以调用其他的 Hook。 与 React 组件不同的是，自定义 Hook 不需要具有特殊的标识。我们可以自由的决定它的参数是什么，以及它应该返回什么（如果需要的话）。换句话说，它就像一个正常的函数。但是它的名字应该始终以 use 开头，这样可以一眼看出其符合 Hook 的规则。 自定义 Hook 是一种自然遵循 Hook 设计的约定，而并不是 React 的特性。 自定义 Hook 必须以 “use” 开头。这个约定非常重要。不遵循的话，由于无法判断某个函数是否包含对其内部 Hook 的调用，React 将无法自动检查你的 Hook 是否违反了 Hook 的规则。 6. fragments12345678910111213141516171819202122232425262728293031// 最初始版本&lt;div&gt; &lt;ChildA /&gt; &lt;ChildB /&gt; &lt;ChildC /&gt;&lt;/div&gt;// v16.2 引入fragmentsconst Fragment = React.Fragment;&lt;Fragment&gt; &lt;ChildA /&gt; &lt;ChildB /&gt; &lt;ChildC /&gt;&lt;/Fragment&gt;// This also works&lt;React.Fragment&gt; &lt;ChildA /&gt; &lt;ChildB /&gt; &lt;ChildC /&gt;&lt;/React.Fragment&gt;// 最后也可以简化成&lt;&gt; &lt;ChildA /&gt; &lt;ChildB /&gt; &lt;ChildC /&gt;&lt;/&gt;// key 是唯一可以传递给 fragments 的属性","tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"如何监听div的高宽改变","date":"2019-05-20T01:39:01.000Z","path":"2019/05/20/JavaScript进阶/如何监听div的高宽改变/","text":"已知情况： document 类型 dom 有 onresize 事件，在浏览器窗口改变大小时会触发； 除了 IE9-10 之外的其他浏览器没有提供给如 div 之类元素的 resize 事件 待解决问题对某个指定元素，比如 div ，通过添加自定义的 onresize 事件，当该 div 的高宽改变时，触发回调函数 解决方案 如果只是想在浏览器窗口大小改变时触发，使用 window.onresize 即可 IE9-10，默认支持元素的 resize 事件，可以直接通过 div.attachEvent(‘onresize’, handler)实现 使用周期性检查判断元素是否发生了变化（浪费性能，不推荐） 通过 scroll 事件（不直观，不推荐），参考：巧妙监测元素尺寸变化 具体做法：在被监测元素里包裹一个跟元素位置大小相同的隐藏块。隐藏块可以滚动，并有一个远远大于它的子元素。当被监测元素尺寸变化时期望能触发隐藏块的滚动事件。 这个方法听起来很简单是不是，但如果你直接这么实现会发现时而行时而不行，问题就在于触发滚动事件的条件。 通过使用 object 元素（给其 type 设置为 ‘text/html’才行）/ iframe 元素（即：document类型元素）来通过 resize 事件监听宿主元素高宽的改变（推荐）, 参考：JS监听div的resize事件 具体做法：设置object元素的style使其填充满div，这样当div的size发生变化时，object的size也会发生变化。然后监听object元素的contentDocument.defaultView(window对象)的resize事件。 总结： IE 直接使用原生 resize 事件，其他浏览器通过为宿主元素添加一个同位置等大小且 type 设置为 ‘text/html’ 的 object 元素，监听 object 元素的 resize 事件","tags":[{"name":"监听元素高宽","slug":"监听元素高宽","permalink":"http://yoursite.com/tags/监听元素高宽/"}]},{"title":"react视图更新过程","date":"2019-05-20T01:39:01.000Z","path":"2019/05/20/React相关/react视图更新过程/","text":"React 原生更新方式首先，react是一个view（视图层）框架。能引起视图变更的只有两个地方：ReactDoM.render(jsx，real-dom)和 setState方法。 程序首次运行时，使用 ReactDoM.render 渲染根组件, 这个过程会递归完成所有子组件的渲染和挂载，最后根组件才挂载完毕。 在接下来的更新流程中，如果某个组件调用了 setState 方法，那么就走到该组件及其子组件的 render 流程，返回一个新的 vdom，diff 后更新real dom。 为什么 setState 存在两种更新方式有可能在组件的生命周期中调用了 setState 方法，因此，要把在组件生命周期的调用缓存起来，等到事务结束时一起批量更新 使用 Redux 之后的更新方式： 状态统一管理，数据流清晰 1234567891011121314151617// 定一个 reducerfunction reducer (state, action) &#123; /* 初始化 state 和 switch case */&#125;// 生成 storeconst store = createStore(reducer)// 监听数据变化重新渲染页面store.subscribe(() =&gt; renderApp(store.getState())) // 重新渲染根组件，浪费性能，且子组件需要的数据也得一级一级的传下去// 当前可以在子组件导入 store，实现精准更新，不过这样的话组件和 store 紧耦合，不好。// 首次渲染页面renderApp(store.getState()) // 后面可以随意 dispatch 了，页面自动更新store.dispatch(...) 使用 React-Redux 之后的更新方式 引入 Provider 和 connect，带来以下改进： 使用 context保存和传递数据 容器组件订阅 store 的变化，针对性渲染，不再是每次都渲染根组件","tags":[{"name":"react原理","slug":"react原理","permalink":"http://yoursite.com/tags/react原理/"}]},{"title":"为什么使用immutable.js（不可变）？","date":"2019-05-20T01:39:01.000Z","path":"2019/05/20/React相关/为什么使用immutable.js/","text":"immutable.js 以一种高性能的方式提供了不可变数据类型immutable.js 的实用功能 保证对象的不可变性，所有操作都会返回一个新的对象（引用地址发生变化） ，同时解决这种深拷贝带来的性能问题 提供深比较两个对象的api：Immutable.is()方法 123456789//和js中对象的比较不同，在js中比较两个对象比较的是地址，//但是在Immutable中比较的是这个对象hashCode和valueOf，//只要两个对象的hashCode相等，值就是相同的，避免了深度遍历，提高了性能。import &#123; Map, is &#125; from 'immutable'const map1 = Map(&#123; a: 1, b: 1, c: 1 &#125;)const map2 = Map(&#123; a: 1, b: 1, c: 1 &#125;)map1 === map2 //falseObject.is(map1, map2) // falseis(map1, map2) // true 在 React 里面的应用（性能优化的场景） 目的：减少不必要的 re-render props 变化或者 state 变化，都会导致更新流程被触发，为了减少不必要的 re-render，总体上有以下两种优化方案： 使用 Component 和 shouldComponentUpdate 结合 equals 方法去进行优化 1equals 方法会对两个对象进行深比较，引用地址不同但是内容完全相同的也被视为相同，用 使用 PureComponent 结合 Immutable.js ，自动优化 123PureComponent 实现了 shouldComponentUpdate 方法，通过浅比较的结果来决定是否 re-render结合 immutable.js 之后，由于每次修改都会返回一个新的引用，因此只要 &quot;===&quot; 返回 false ，就说明数据发生了变化，就需要重新渲染。 在 Redux 里面的应用（浅比较新旧state，使用immutable可以保证state安全更新）123451. combineReducers 遍历所有的 reducer 键值对，根据每一个 reducer 返回的 state 层，构建出一个新的根 state 对象。2. 每次循环中，combineReducers 会浅比较当前 state 层与 reducer 返回的 state 层，如果 reducer 返回了新的对象，他们就不是浅相等的，同时设置 hasChanged 为 true。3. 循环结束后检查 hasChanged 的值，如果为 true，就会返回新构建的 state 对象，否则返回当前 state 对象 在 React-Redux 里面的应用参考：connect 的实现 1234567891011121314151617181920212223242526272829303132333435export const connect = (mapStateToProps) =&gt; (WrappedComponent) =&gt; &#123; class Connect extends Component &#123; static contextTypes = &#123; store: PropTypes.object &#125; constructor () &#123; super() this.state = &#123; allProps: &#123;&#125; &#125; &#125; componentWillMount () &#123; const &#123; store &#125; = this.context this._updateProps() store.subscribe(() =&gt; this._updateProps()) // 监听 store 的变化 &#125; _updateProps () &#123; const &#123; store &#125; = this.context let stateProps = mapStateToProps(store.getState(), this.props) // 额外传入 props，让获取数据更加灵活方便 this.setState(&#123; allProps: &#123; // 整合普通的 props 和从 state 生成的 props ...stateProps, ...this.props &#125; &#125;) &#125; render () &#123; return &lt;WrappedComponent &#123;...this.state.allProps&#125; /&gt; &#125; &#125; return Connect&#125; React-Redux 使用浅比较来决定它包装的组件是否需要重新渲染。 React-Redux 的 connect 方法生成的组件通过 浅比较根 state 的引用变化 与 mapStateToProps 函数的返回值，来判断包装的组件是否需要重新渲染。 connect 订阅根 state 的更新，当根 state 不变时，流程结束; 当根 state 变化时，观察 mapStateToProps 返回值是否变化，不变，则不更新 props，变的话更新props，子组件更新。 总结：用到浅比较的地方都需要不可变类型React 本身使用不可变数据，则引用类型作为 props 传递时，不用担心某个修改不会触发渲染。 Redux 中使用 combineReducers，对新旧 state 进行 “===” 比较，即只比较引用地址。使用 immutable.js 同样可以保证，只要数据变化了，一定返回新的地址，也就一定会返回新的 state React-Redux 中使用的 connect ，比较 state 用的是 “===”, 比较 mapStateToProps 的返回值也是用单层”===” 补充：React 中浅比较的使用场景： PureComponent 的 shouldComponentUpdate 每个 reducer 的返回值与旧值的比较 mapStateToProps 返回值的比较 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 用原型链的方法const hasOwn = Object.prototype.hasOwnProperty// 这个函数实际上是ES6中Object.is()的polyfill，即\"===\"的增强版，让 +0 != -0，NaN === NaNfunction is(x, y) &#123; if (x === y) &#123; return x !== 0 || y !== 0 || 1 / x === 1 / y &#125; else &#123; return x !== x &amp;&amp; y !== y &#125;&#125;export default function shallowEqual(objA, objB) &#123; // 首先对基本数据类型的比较 if (is(objA, objB)) return true // 由于Obejct.is()可以对基本数据类型做一个精确的比较， 所以如果不等 // 只有一种情况是误判的，那就是object,所以在判断两个对象都不是object // 之后，就可以返回false了 if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) &#123; return false &#125; // 过滤掉基本数据类型之后，就是对对象的比较了 // 首先拿出key值，对key的长度进行对比 const keysA = Object.keys(objA) const keysB = Object.keys(objB) // 长度不等直接返回false if (keysA.length !== keysB.length) return false // key相等的情况下，在去循环比较 for (let i = 0; i &lt; keysA.length; i++) &#123; // key值相等的时候 // 借用原型链上真正的 hasOwnProperty 方法，判断ObjB里面是否有A的key的key值 // 属性的顺序不影响结果也就是&#123;name:'daisy', age:'24'&#125; 跟&#123;age:'24'，name:'daisy' &#125;是一样的 // 最后，对对象的value进行一个基本数据类型的比较，返回结果 if (!hasOwn.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) &#123; return false &#125; &#125; return true&#125; 浅比较总结（即：使用===进行比较，分整体和单层的情况）： 引用不同： 返回 false 引用相同，第一层的key的长度不同：返回 false 引用相同，第一层的key的长度相同，接着使用 “===” 依次比较每个 key 对应的 value 是否相等： 全相等：true 任何不相等：false connect 工作原理 正常初始化，render，挂载 在 componentDidMount 钩子中，通过 store.subscrible 订阅 store 的变化；当store变化时，比较 mapStateToProps 返回值是否发生变化，变化的话，执行本组件的 setState 方法，重新渲染 render 中 return 的子组件。 比较前后 state 变化用的是 “===” 运算符，比较 mapStateToProps 返回值用的是浅(一层)比较 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// connect 部分源码handleChange() &#123; // 判断是否已经取消订阅 if (!this.unsubscribe) &#123; return &#125; // 如果当前状态和上次状态相同，退出 const storeState = this.store.getState() const prevStoreState = this.state.storeState if (pure &amp;&amp; prevStoreState === storeState) &#123; return &#125; if (pure &amp;&amp; !this.doStatePropsDependOnOwnProps) &#123; // 当前状态和上次状态浅（第一层）比较：updateStatePropsIfNeeded const haveStatePropsChanged = tryCatch(this.updateStatePropsIfNeeded, this) // 如果没有变化，退出 if (!haveStatePropsChanged) &#123; return &#125; // 比较出错 if (haveStatePropsChanged === errorObject) &#123; this.statePropsPrecalculationError = errorObject.value &#125; // 需要预计算 this.haveStatePropsBeenPrecalculated = true &#125; // 标记store发生变化(初始化) this.hasStoreStateChanged = true // 重新改变state,也就重新触发render this.setState(&#123; storeState &#125;)&#125;// ！！！！ 浅比较 props （比较第一层）是否有变化 ！！！！updateStatePropsIfNeeded() &#123; const nextStateProps = this.computeStateProps(this.store, this.props) if (this.stateProps &amp;&amp; shallowEqual(nextStateProps, this.stateProps)) &#123; return false &#125; // 更新stateProps为下一个计算后的state this.stateProps = nextStateProps return true&#125; 最后总结： 正是因为 React、Redux 中有诸多使用浅比较（直接”\\=\\==”或者单层比较”\\=\\==”）的场景存在，使用 immutable 能保证每次操作都返回一个新的对象， 每一次 state 或者 props 变化时页面都能够重新渲染。","tags":[{"name":"redux","slug":"redux","permalink":"http://yoursite.com/tags/redux/"}]},{"title":"从createStore和applyMiddleWare看redux 中间件的原理","date":"2019-05-20T01:39:01.000Z","path":"2019/05/20/React相关/从createStore和applyMiddleWare看redux 中间件的原理/","text":"createStore 部分源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104// createStore// enhancer 为 applyMiddleWare 的执行结果，即 applyMiddleWare([middleware1, middleware2])export default function createStore(reducer, preloadedState, enhancer) &#123; // 处理只有两个参数的情况 if (typeof preloadedState === 'function' &amp;&amp; typeof enhancer === 'undefined') &#123; enhancer = preloadedState preloadedState = undefined &#125; // enhancer 为 function，创建 store 的流程转交给 applyMiddleWare 控制 if (typeof enhancer !== 'undefined') &#123; if (typeof enhancer !== 'function') &#123; throw new Error('Expected the enhancer to be a function.') &#125; // 给 applyMiddleWare 传入 createStore 后执行applyMiddleWare // 给 执行后返回的函数传入 reducer 和 state return enhancer(createStore)(reducer, preloadedState) &#125; // 没有传入 enhancer 的情况，即无需修改 dispatch，此时我们来定义 store 相关的内容，包括 // store.getState() // store.dispatch() // store.subscribe() // store.replaceReducer() // ... ...&#125;// applyMiddleWare，目的：返回一个 enhancer// enhancer 的目的：创建一个 dispatch 被替换的新的storeexport default function applyMiddleware(...middlewares) &#123; // 返回的函数即为 enhancer return createStore =&gt; (...args) =&gt; &#123; // 调用无 enhancer 参数的 createStore 函数，生成标准 store const store = createStore(...args) // 改造 dispatch 完成前，不允许调用 dispatch let dispatch = () =&gt; &#123; throw new Error( 'Dispatching while constructing your middleware is not allowed. ' + 'Other middleware would not be applied to this dispatch.' ) &#125; // 中间件所需的两个方法 const middlewareAPI = &#123; getState: store.getState, dispatch: (...args) =&gt; dispatch(...args) &#125; // chain 里面存放的是 (next) =&gt; (action) =&gt; &#123;...&#125;，即接收 dispatch ，并改造之的函数 // 以 redux-thunk 为例，此处传给中间件 &#123;getState, dispatch&#125; 后执行，返回一个接收 next 的函数 const chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)) // 即：dispatch = a(b(c(d(dispatch)))), // 中间件 d 用的是原生 dispatch， // 中间件 c 用的是 d 返回的 dispatch // ... ... // 注意：每一个的执行结果都是一个 dispatch // 即：a(b(c(d(dispatch)))) 可以看作： // a(dispatch_b) b(dispatch_c) c(dispatch_d) d(dispatch) // 视图层在执行 dispatch 的时候，实际执行的是 a 改造后的 dispatch， // 由于 a 产生的 dispatch 需要 b 返回的 dispatch_b 当参数（即依赖 dispatch_b）, 因此需要执行 b(dispatch_c), 如此下去，直到 d 执行，再一层层返回，类似递归的过程 dispatch = compose(...chain)(store.dispatch) // 返回被替换掉 dispatch 的 store return &#123; ...store, // 用新的 dispatch 替换 store 里面的原生 dispatch dispatch &#125; &#125;&#125;// composeexport default function compose(...funcs) &#123; if (funcs.length === 0) &#123; // 透传 return arg =&gt; arg &#125; if (funcs.length === 1) &#123; return funcs[0] &#125; // 作用：compose(a,b,c,d)(dispatch) 转换成 a(b(c(d(dispatch)))) // 而每一个 middleware 都返回一个新的 dispatch // 可以看到在 dispatch 构造阶段， args 被传递给了最里层的中间件函数 return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))&#125;// redux-thunk 中间件// 接收 dispatch 和 getState 函数function createThunkMiddleware(extraArgument) &#123; return (&#123; dispatch, getState &#125;) =&gt; next =&gt; action =&gt; &#123; if (typeof action === 'function') &#123; // 如果 action 是一个函数，则执行它 return action(dispatch, getState, extraArgument); &#125; // 否则，用传入的 next 去处理该 action return next(action); &#125;;&#125;const thunk = createThunkMiddleware();thunk.withExtraArgument = createThunkMiddleware;export default thunk; 中间件执行过程分析参考：理解 redux 中间件 假如有以下两个中间件： 1234567891011121314const logger = store =&gt; next =&gt; action =&gt; &#123; console.log('dispatching', action) return next(action)&#125;const collectError = store =&gt; next =&gt; action =&gt; &#123; try &#123; return next(action) &#125; catch (err) &#123; console.error('Error!', err) &#125;&#125;// 调用的时候从后往前执行applyMiddleWare([collectError, logger]) 构造过程： 123456let next = store.dispatch;let dispatch1 = logger(store)(next); // 这时候的console.log('dispatching', action) 是没有执行的 let dispatch2 = collectError(store)(dispatch1);// 这时候的console.log('Error!', err) 也是没有执行的 store.dispatch = dispatch2; 执行过程： dispatch 的时候，先执行 dispatch2 ，然后 dispatch2 里面使用了 next函数，即 dispatch1，所以转去执行1，1执行完成后，2继续执行，有点像递归。 注意事项如果在 调用 next(action) 之前， 使用 await 调用， 会阻塞住整个中间件的链式调用，然后在 await 位置立刻返回， 造成不符合预期的结果。 如果要在中间件中使用异步操作， 需要放在 next(action) 之后， 这样不会影响其他的中间件调用， 用可以把异步的逻辑放到最后执行。","tags":[{"name":"redux","slug":"redux","permalink":"http://yoursite.com/tags/redux/"}]},{"title":"深入理解css权重","date":"2019-05-14T13:39:01.000Z","path":"2019/05/14/CSS/深入理解css权重/","text":"参考：https://juejin.im/post/5afaa228f265da0b8070e41d#heading-11 元素 贡献值 继承、* 0，0，0，0 每个标签 0，0，0，1 类、伪类 0，0，1，0 ID 1，0，0，0 行内样式 1，0，0，0 !important 无穷大 max-height、max-width覆盖width、height 大于无穷大 min-height、min-width 大于max-height、max-width 总结 计算规则 遇到有贡献值的就进行累加，例如： 12345div ul li ---&gt; 0,0,0,3.nav ul li ---&gt; 0,0,1,2a:hover ---&gt; 0,0,1,1.nav a ---&gt; 0,0,1,1#nav p ---&gt; 0,1,0,1 数位没有进位： 0,0,0,5+0,0,0,5 = 0,0,0,10而不是0,0,1,0，所以不会存在10个div能赶上一个类选择器的情况 。 权重不会继承，所以父元素的权重再高也和子元素没有关系 如果有!important那么相加的那些无论多高就不管用， 如果有max-height/max-width那么!important不管用， 如果同时有min-height/min-width和 max-height/max-width，那么max-height/max-width的不管用。","tags":[{"name":"css权重","slug":"css权重","permalink":"http://yoursite.com/tags/css权重/"}]},{"title":"不能使用箭头函数的场景","date":"2019-05-14T13:39:01.000Z","path":"2019/05/14/JavaScript基础/不能使用箭头函数的场景/","text":"箭头函数的目的1. 写法更简洁2. 利于实现纯函数：给定输入的情况下，输出总是一致的，即不受外部状态影响。箭头函数要实现类似纯函数的效果，给定必须剔除外部状态。所以当你定义一个箭头函数，在普通函数里常见的this、arguments、caller是统统没有的（只能通过闭包从父作用域获取） 不适合使用箭头函数的场景1. 定义字面量方法，即对象的方法123456789101112const calculator = &#123; array: [1, 2, 3], sum: () =&gt; &#123; console.log(this === window); // =&gt; true return this.array.reduce((result, item) =&gt; result + item); &#125;&#125;;console.log(this === window); // =&gt; true// Throws \"TypeError: Cannot read property 'reduce' of undefined\"calculator.sum(); calculator.sum 使用箭头函数来定义，但是调用的时候会抛出 TypeError，因为运行时 this.array 是未定义的，调用 calculator.sum 的时候，执行上下文里面的 this 仍然指向的是 window，原因是箭头函数把函数上下文绑定到了 window 上，this.array 等价于 window.array，显然后者是未定义的。 解决的办法是，使用函数表达式或者方法简写（ES6 中已经支持）来定义方法，这样能确保 this 是在运行时是由包含它的上下文决定的，修正后的代码如下 JS Bin： 12345678const calculator = &#123; array: [1, 2, 3], sum() &#123; console.log(this === calculator); // =&gt; true return this.array.reduce((result, item) =&gt; result + item); &#125;&#125;;calculator.sum(); // =&gt; 6 这样 calculator.sum 就变成了普通函数，执行时 this 就指向 calculator 对象，自然能得到正确的计算结果。 2. 原型的方法1234567891011function Cat(name) &#123; this.name = name;&#125;Cat.prototype.sayCatName = () =&gt; &#123; console.log(this === window); // =&gt; true return this.name;&#125;;const cat = new Cat('Mew');cat.sayCatName(); // =&gt; undefined 使用传统的函数表达式就能解决问题 JS Bin： 1234567891011function Cat(name) &#123; this.name = name;&#125;Cat.prototype.sayCatName = function () &#123; console.log(this === cat); // =&gt; true return this.name;&#125;;const cat = new Cat('Mew');cat.sayCatName(); // =&gt; 'Mew' sayCatName 变成普通函数之后，被调用时的执行上下文就会指向新创建的 cat 实例。 3. 定义事件回调函数this 是 JS 中很强大的特性，可以通过多种方式改变函数执行上下文，JS 内部也有几种不同的默认上下文指向，但普适的规则是在谁上面调用函数 this 就指向谁，这样代码理解起来也很自然，读起来就像在说，某个对象上正在发生某件事情。（针对ES5，完全OK） 但是，箭头函数在声明的时候就绑定了执行上下文，要动态改变上下文是不可能的，在需要动态上下文的时候它的弊端就凸显出来。比如在客户端编程中常见的 DOM 事件回调函数（event listenner）绑定，触发回调函数时 this 指向当前发生事件的 DOM 节点，而动态上下文这个时候就非常有用，比如下面这段代码试图使用箭头函数来作事件回调函数： 12345const button = document.getElementById('myButton');button.addEventListener('click', () =&gt; &#123; console.log(this === window); // =&gt; true this.innerHTML = 'Clicked button';&#125;); 在全局上下文下定义的箭头函数执行时 this 会指向 window，当单击事件发生时，浏览器会尝试用 button 作为上下文(上下文可以理解为一个特殊对象)来执行事件回调函数，但是箭头函数预定义的上下文是不能被修改的，这样 this.innerHTML 就等价于 window.innerHTML，而后者是没有任何意义的。 使用函数表达式就可以在运行时动态的改变 this，修正后的代码 JS Bin： 12345const button = document.getElementById('myButton');button.addEventListener('click', function() &#123; console.log(this === button); // =&gt; true this.innerHTML = 'Clicked button';&#125;); 当用户单击按钮时，事件回调函数中的 this 实际指向 button，这样的 this.innerHTML = ‘Clicked button’ 就能按照预期修改按钮中的文字。 4. 定义构造函数构造函数中的 this 指向新创建的对象，当执行 new Car() 的时候，构造函数 Car 的上下文就是新创建的对象，也就是说 this instanceof Car === true。显然，箭头函数是不能用来做构造函数， 实际上 JS 会禁止你这么做，如果你这么做了，它就会抛出异常。 换句话说，箭头构造函数的执行并没有任何意义，并且是有歧义的。比如，当我们运行下面的代码： 12345const Message = (text) =&gt; &#123; this.text = text;&#125;;// Throws \"TypeError: Message is not a constructor\"const helloMessage = new Message('Hello World!'); 构造新的 Message 实例时，JS 引擎抛了错误，因为 Message 不是构造函数。在笔者看来，相比旧的 JS 引擎在出错时悄悄失败的设计，ES6 在出错时给出具体错误消息是非常不错的实践。可以通过使用函数表达式或者函数声明 来声明构造函数修复上面的例子： 12345const Message = function(text) &#123; this.text = text;&#125;;const helloMessage = new Message('Hello World!');console.log(helloMessage.text); // =&gt; 'Hello World!' 5. 想清晰表达逻辑的代码箭头函数允许你省略参数两边的括号、函数体的花括号、甚至 return 关键词，这对编写更简短的代码非常有帮助。 但是，在实际的软件工程中，代码写完之后会被很多工程师阅读，真正的 write once, read many times，在代码可读性方面，最短的代码可能并不总是最好的。一定程度上，压缩了太多逻辑的简短代码，阅读起来就没有那么直观，比如下面的例子： 1234const multiply = (a, b) =&gt; b === undefined ? b =&gt; a * b : a * b;const double = multiply(2);double(3); // =&gt; 6multiply(2, 3); // =&gt; 6 改写成普通函数： 12345678function multiply(a, b) &#123; if (b === undefined) &#123; return function (b) &#123; return a * b; &#125; &#125; return a * b;&#125; 总结在需要动态上下文的场景中使用箭头函数你要格外的小心，这些场景包括：定义对象方法、定义原型方法、定义构造函数、定义事件回调函数。 参考：https://zhuanlan.zhihu.com/p/26540168","tags":[{"name":"JavaScript基础","slug":"JavaScript基础","permalink":"http://yoursite.com/tags/JavaScript基础/"}]},{"title":"从输入url到页面展现发生了什么","date":"2019-05-14T13:39:01.000Z","path":"2019/05/14/JavaScript基础/从输入url到页面展现发生了什么/","text":"在浏览器地址栏输入URL 浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤 如果资源未缓存，发起新请求 如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。 检验新鲜通常有两个HTTP头进行控制Expires和Cache-Control： HTTP1.0提供Expires，值为一个绝对时间表示缓存新鲜日期 HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最大新鲜时间 浏览器解析URL获取协议，主机，端口，path 浏览器组装一个HTTP（GET）请求报文 浏览器获取主机ip地址，过程如下： 浏览器缓存 本机缓存 hosts文件 路由器缓存 ISP DNS缓存 DNS递归查询（可能存在负载均衡导致每次IP不一样） 打开一个socket与目标IP地址，端口建立TCP链接，三次握手如下（前两次有syn）： 1234567891011121314151617181920 客户端发送一个TCP的SYN=1，Seq=X的包到服务器端口 服务器发回SYN=1， ACK=X+1， Seq=Y的响应包 客户端发送ACK=Y+1， Seq=Z （补充：3次握手的目的主要是防止失效的握手报文抵达，使server陷入等待） ``` 7. TCP链接建立后发送HTTP请求8. 服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序（反向代理的情况）9. 服务器检查HTTP请求头是否包含缓存验证信息如果验证缓存新鲜，返回304等对应状态码10. 处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作11. 服务器将响应报文通过TCP连接发送回浏览器12. 浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重用，关闭TCP连接的四次握手如下： 主动方发送Fin=1， Ack=Z， Seq= X报文 被动方发送ACK=X+1， Seq=Z报文 被动方发送Fin=1， ACK=X， Seq=Y报文 主动方发送ACK=Y， Seq=X报文 (补充：前两次是主动方告诉被动方，主动方不再发送数据了，此时被动方还可以给主动方发数据；后两次说明被动方也没有要发送的数据了) ` 浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同 如果资源可缓存，进行缓存 对响应进行解码（例如gzip压缩） 根据资源类型决定如何处理（假设资源为HTML文档） 解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本，这些操作没有严格的先后顺序，以下分别解释 参考：渲染树构建、布局及绘制 构建DOM树： Tokenizing：根据HTML规范将字符流解析为标记 Lexing：词法分析将标记转换为对象并定义属性和规则 DOM construction：根据HTML标记关系将对象组成DOM树 解析过程中遇到图片、样式表、js文件，启动下载 构建CSSOM树： Tokenizing：字符流转换为标记流 Node：根据标记创建节点 CSSOM：节点创建CSSOM树 （补充：css媒体类型和媒体查询不会阻塞渲染，但都会下载） 根据DOM树和CSSOM树构建渲染树: 从DOM树的根节点遍历所有可见节点，不可见节点包括： 1）script,meta这样本身不可见的标签。 2)被css隐藏的节点，如display: none 对每一个可见节点，找到恰当的CSSOM规则并应用 发布可视节点的内容和计算样式 进入layout布局阶段 到目前为止，我们计算了哪些节点应该是可见的以及它们的计算样式，但我们尚未计算它们在设备视口内的确切位置和大小—这就是“布局”阶段，也称为“自动重排”。 为弄清每个对象在网页上的确切大小和位置，浏览器从渲染树的根节点开始进行遍历。 布局流程的输出是一个“盒模型”，它会精确地捕获每个元素在视口内的确切位置和尺寸：所有相对测量值都转换为屏幕上的绝对像素。 进入painting绘制阶段 最后，既然我们知道了哪些节点可见、它们的计算样式以及几何信息，我们终于可以将这些信息传递给最后一个阶段：将渲染树中的每个节点转换成屏幕上的实际像素。这一步通常称为“绘制”或“栅格化”。 补充： webkit主流程 解析HTML，生成DOM树，解析CSS，生成CSSOM树 将DOM树和CSSOM树结合，生成渲染树(Render Tree) Layout:根据生成的渲染树，进行Layout，得到节点的几何信息（位置，大小） Painting:根据渲染树以及回流得到的几何信息，得到节点的绝对像素 Display:将像素发送给GPU，展示在页面上。（这一步其实还有很多内容，比如会在GPU将多个合成层合并为同一个层，并展示在页面中。而css3硬件加速的原理则是新建合成层，这里我们不展开 补充：一些易混淆的点 关于阻塞： 由上图可知，cssom树和dom树是并行构建的，即css不阻塞DOM；cssdom和dom都位于render前面，因此二者都阻塞页面渲染 js的下载和执行会阻塞dom的构建，但可以通过defer和async让下载过程不阻塞，但执行过程一定阻塞（因为js可以修改dom）。除了async的脚本不会阻塞DOMContentLoaded,其余类型脚本都会阻塞。 css样式的下载不会影响js的下载，但会阻塞js的执行(因为js可能会获取样式)；css不会阻塞dom树的构建，因此继续向下解析，有可能解析到script时css还没处理完，则此js的执行会被阻塞。 总结：CSS不阻塞DOM构建而阻塞JS脚本执行，JS脚本下载（可解决）和执行阻塞DOM树构建 DOM树和渲染树的区别 渲染树实际上就是一个计算好样式，与HTML对应的（包括哪些显示，那些不显示）的Tree。它是由渲染对象组成的，每个渲染对象都有一个布局（reflow）方法，实现其布局或回流。 白屏时间和首屏时间 白屏时间指head标签解析完毕，开始解析body之前的时间 首屏时间指首屏的所有资源都加载完毕的时间 我们常常提到的reflow和repaint是什么？ 从上面的流程中，可以看到页面初始化时，至少有一次layout和paint；这个过程是不可缺少的，那么我们通常所提到的reflow和repaint是什么？ 对渲染树的布局可以分为全局和局部的，全局即对整个渲染树进行重新布局，如当我们改变了窗口尺寸或方向或者是修改了根元素的尺寸或者字体大小等；而局部布局可以是对渲染树的某部分或某一个渲染对象进行重新布局。 一旦cssom或者dom被修改，即渲染树被修改，该变化的渲染对象需要layout；当然，这次layout可能会导致相邻或者父子关系的其他节点的reflow，当渲染树变化较多或者某些操作触发时，会触发整个页面的layout。 补充：html解析过程触发的事件 浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时document.readystate为loading HTML解析器遇到没有async和defer的script时，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用document.write()把文本插入到输入流中。同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容 当解析器遇到设置了async属性的script时，开始下载脚本并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器不会停下来等它下载。异步脚本禁止使用document.write()，它们可以访问自己script和之前的文档元素 当文档完成解析，document.readState变成interactive所有defer脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，禁止使用document.write() 浏览器在Document对象上触发DOMContentLoaded事件 此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，document.readState变为complete,window触发load事件 显示页面（HTML解析过程中会逐步显示页面） 补充：影响layout和repaint的属性 影响 layout 的属性 宽高 边距 位置 表现 边框 定位 字体 width padding position display border text-align font-size height margin top float border-width overflow-y font-weight 影响repaint的属性 背景 边框 其他 background border-style color background-image border-radius visibility background-repeat outline text-decoration background-position outline-style box-shadow background-size outline-color – |outline-width 补充：css3动画优劣 好处： 使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘 对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。 css3硬件加速的坑: 如果你为太多元素使用css3硬件加速，会导致内存占用较大，会有性能问题。 在GPU渲染字体会导致抗锯齿无效（导致动画里的字体是模糊的）。这是因为GPU和CPU的算法不同。因此如果你不在动画结束的时候关闭硬件加速，会产生字体模糊。 https://segmentfault.com/a/1190000017329980 https://segmentfault.com/a/1190000010298038#articleHeader4","tags":[{"name":"JavaScript基础","slug":"JavaScript基础","permalink":"http://yoursite.com/tags/JavaScript基础/"}]},{"title":"跨域问题总结","date":"2019-05-14T13:39:01.000Z","path":"2019/05/14/JavaScript基础/跨域问题总结/","text":"同一个域的定义：协议名+主机名+端口号 相同。什么导致了跨域：运行的js脚本跟所访问的资源不在同一个域。比如：前台项目和后台项目分别打包部署在不同的服务器。为什么要跨域： 浏览器为了安全，有一个同源策略。它会禁止使用从不同域加载到的数据。几种跨域方法 适用于与服务端通信的方法： JSONP：jsonp 全称是JSON with Padding,即内嵌的json，凡是拥有scr这个属性的标签都可以跨域例如&lt;script&gt;，\\&lt;img&gt;,\\&lt;iframe&gt; CORS：服务端处理 Nginx：请求转发/反向代理（cors失败主要是浏览器的问题，并不是服务器不响应，因此绕开浏览器的跨域机制就可以了。让所有ajax请求发送至本机的nginx，然后由nginx去请求server，nginx不是浏览器没有cors机制，因此可以成功，好处是不需要服务器参与） 适用于有关联关系的不同tab或者同一tab不同document的通信： 注意：两个窗口能通信的前提是，一个窗口以iframe的形式存在于另一个窗口，或者一个窗口是从另一个窗口通过window.open()或者超链接的形式打开的（同样可以用window.opener获取源窗口）；换句话说，你要交换数据，必须能获取目标窗口(target window)的引用，不然两个窗口之间毫无联系，想通信也无能为力。 document.domain 浏览器在检测是否同源时肯定要检测域名是否相同，它是通过document.domain属性来获取当前页面域名的； document.domain属性不能随便更改，但可以通过js将document.domain属性设置为当前document.domain属性值的后缀； 例如，假设在 http://store.company.com/dir/other.html中的一个脚本执行了下列语句document.domain = “company.com”，这条语句执行之后，浏览器将会成功地通过对http://company.com/dir/page.html的同源检测，但不能设置 document.domain为othercompany.com.； 如果需要跨域访问的网站和本网站端口、协议均相同，只有域名不同，而且需要跨域访问的网站的域名是本网站的后缀，则可以使用document.domain暂时更改当前document对象的域名值，实现跨域访问； 此种跨域访问限制颇多，空间上，只能跨域访问协议、端口相同的且域名是本网站后缀的网站，时间上，一旦原网站重新刷新页面，document.domain值恢复原状，不能继续跨域访问，所以这种跨域访问策略只能算是局部的、暂时的、基础域名相同的网站间的跨域访问； window.name 浏览器一个窗口（标签页）的window.name属性在时间上是全局的，无论一个窗口中的页面如何跳转，window.name属性不变; 可以看到，如果在一个标签里面跳转网页的话，我们的 window.name 是不会改变的； 由于安全原因，浏览器始终会保持 window.name 是string类型； window.name比document.domain更强大，可以从任意页面获取string类型的数据； postMessage onmessage 而postMessage的使用方式也相当简单： otherWindow.postMessage(message, targetOrigin, [transfer]); otherWindow是对接收方窗口的引用，一般可以是以下几种方式： window.frames[0].postMessage document.getElementsByTagName(‘iframe’)[0].contentWindow window.opener.postMessage event.source.postMessage window.open 返回的引用 参考：postMessage","tags":[{"name":"JavaScript基础","slug":"JavaScript基础","permalink":"http://yoursite.com/tags/JavaScript基础/"}]},{"title":"函数常见的有几种调用方式","date":"2019-05-14T13:39:01.000Z","path":"2019/05/14/JavaScript进阶/关于new操作符的一些思考/","text":"函数常见的有几种调用方式？ new 调用 作为对象的方法调用（function关键字声明的） 全局作用域声明的函数的调用 作为定时器回调函数 作为事件回调函数 作为普通回调函数(比如：node环境的回调) new调用和普通调用的区别？new调用除了会执行（构造）函数外，还多了返回对象(this或者指定对象)和连接原型的操作。","tags":[{"name":"JavaScript核心","slug":"JavaScript核心","permalink":"http://yoursite.com/tags/JavaScript核心/"}]},{"title":"GitFlow工作流","date":"2019-05-14T13:39:01.000Z","path":"2019/05/14/杂项/Git Flow 工作流/","text":"基本概念 git本地仓库的三个组成部分：工作区（Working Directoty），暂存区（Stage），历史记录区（History） 工作区：在git管理下的正常目录都算是工作区，我们平时的编辑工作都是在工作区完成 暂存区：临时区域。里面存放将要提交文件的快照 历史区：git commit 后的记录区 三个区的转换关系以及转换所使用的命令： git reset 和 git reverse 和 git checkout 的区别 共同点：用来撤销代码仓库中的某些更改 不同点： git reset 可以将一个分支的末端指向之前的一个commit。然后在下次git执行垃圾回收的时候，会把这个commit之后的commit都扔掉。git reset还支持三种标记，用来标记reset指令影响的范围： –mixed: 会影响暂存区和历史记录区。默认值 –soft：只影响历史记录区 –hard；三个区都有影响 git checkout 可以将HEAD移到一个新的分支，并更新工作目录。因为可能会覆盖本地的修改，所以执行这个指令之前，需要stash或者commit暂存区和工作区的修改 git revert 和 git reset 的目的是一样的，但是做法不同，他会以创建新的 commit的方式来撤销commit，这样能保留之前的commit历史，比较安全。 GitFlow 基本流程 名称 说明 master 主分支 develop 主开发分支 feature 新功能分支，一般一个新功能对应一个分支，对于功能的拆分需要比较合理，以避免一些后面不必要的代码冲突 release 发布分支，发布时候用的分支，一般测试时候发现的bug在这个分支进行修复 hotfix hotfix 分支，紧急修复 bug 的时候用 GitFlow 的优势 并行开发：每个新功能都会建立一个新的 feature 分支，从而和已经完成的功能隔离开来，而且只有在新功能完成开发的情况下，其对应的 feature 分支才会合并到主开发分支上（也就是我们经常说的 develop 分支）。另外，如果你正在开发某个功能，同时又有一个新的功能需要开发，你只需要提交当前 feature 的代码，然后创建另外一个 feature 分支并完成新功能开发。然后再切回之前的 feature 分支即可继续完成之前功能的开发。 协作开发：GitFlow 还支持多人协同开发，因为每个 feature 分支上改动的代码都只是为了让某个新的 feature 可以独立运行。同时我们也很容易知道每个人都在干啥。 支持紧急修复：GitFlow 还包含了 hotfix 分支。这种类型的分支是从某个已经发布的 tag 上创建出来并做一个紧急的修复，而且这个紧急修复只影响这个已经发布的 tag，而不会影响到你正在开发的新 feature。 GitFlow 流程图 feature 分支都是从 develop 分支创建，完成后再合并到 develop 分支上，等待发布。 当需要发布时，我们从 develop 分支创建一个 release 分支 然后这个 release 分支会发布到测试环境进行测试，如果发现问题就在这个分支直接进行修复。在所有问题修复之前，我们会不停的重复发布-&gt;测试-&gt;修复-&gt;重新发布-&gt;重新测试这个流程。 发布结束后，这个 release 分支会合并到 develop 和 master 分支，从而保证不会有代码丢失。 master 分支只跟踪已经发布的代码，合并到 master 上的 commit 只能来自 release 分支和 hotfix 分支。 hotfix 分支的作用是紧急修复一些 Bug。它们都是从 master 分支上的某个 tag 建立，修复结束后再合并到 develop 和 master 分支上。 注意： 先有一个 master 然后从 master 拉取一个 develop， 以后它负责维护最新的功能； 从 develop 新建各种 feature 分支，负责各个功能开发 feature 通过 PR／MR 的方式合并回 develop 分支； release 从 develop 拉取，进行测试环境测试 对于 release 流程，则是要注意几点（重要）： 如果 release 分支上有 bug 需要修复，直接在 release 分支上完成； release 分支上的 bug 修复要持续通过 PR／MR 的方式合并回 develop 分支； 最后确认发版的时候才把 release 分支直接合并到 master 分支。 对于 hotfix 流程，则是要注意几点： 从 master 分支发起，修复完要同时合并到 develop 和 master。 PR 和 MR 的区别PR 和 MR 的全称分别是 pull request 和 merge request。解释它们两者的区别之前，我们需要先了解一下 Code Review，因为 PR 和 MR 的引入正是为了进行 Code Review。 Code Review 是指在开发过程中，对代码的系统性检查。通常的目的是查找系统缺陷，保证代码质量和提高开发者自身水平。 Code Review 是轻量级代码评审，相对于正式代码评审，轻量级代码评审所需要的各种成本要明显低的多，如果流程正确，它可以起到更加积极的效果。 然后我们需要了解下 fork 和 branch，因为这是 PR 和 MR 各自所属的协作流程。 fork 是 git 上的一个协作流程。通俗来说就是把别人的仓库备份到自己仓库，修修改改，然后再把修改的东西提交给对方审核，对方同意后，就可以实现帮别人改代码的小目标了。 fork 包含了两个流程： fork 并更新某个仓库(提交修改申请) 同步 fork（获取远程最新） 和 fork 不同，branch 并不涉及其他的仓库，操作都在当前仓库完成。 所以 PR 和 MR 的最大区别就在于此。 参考： git常见面试问题 git rebase 和 git merge","tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"移动端适配相关","date":"2019-05-14T13:39:01.000Z","path":"2019/05/14/移动端/移动端适配相关/","text":"PC端 设备独立像素（即css像素），等于显示器的物理像素。 使用@media适配不同分辨率 移动端在不同的屏幕上，CSS像素所呈现的物理尺寸是一致的，而不同的是CSS像素所对应的物理像素具数是不一致的。在普通屏幕下1个CSS像素对应1个物理像素，而在Retina屏幕下，1个CSS像素对应的却是4个物理像素。 由于移动端屏幕尺寸一般都比较小，在浏览为pc设计的网站时，如果按照移动设备的宽度(visual viewport)去渲染网页，会出现布局错乱，无法正常浏览。 为了解决这个问题，移动端在默认情况下，给layout viewport一个较大的宽度，一般是980px。这样的话，pc网站就能按照980px去渲染，为了在一屏内显示完全，移动端浏览器（iPhone、ipad）会自动计算initial-scale的值，以保证layout viewport的宽度在缩放后就是浏览器可视区域的宽度，也就是说不会出现横向滚动条。 在mata标签里面设置缩放不同于用户手动缩放页面，前者是修改layout viewport的css宽度大小，参照物是ideal viewport的css宽度。后者是更改1px css像素所占用的物理像素数，实际css的大小不产生变化，用户对页面的缩放由浏览器自动调整渲染效果（即自动计算dpr=物理像素/css像素），我们不用关心后者。 layout viewport, ideal viewport, visual viewport 都是用css宽度计算。 可以通过设置viewport的width，或者initial-scale，直接或间接调整layout viewport的css宽度。 ideal viewport ，即为正好铺满手机屏幕的css宽度。这个宽度因设备而异，不过可以通过width=device-width 以及 initial-scale=1 来让 layout viewport = ideal viewport，不会出现滚动条。 仅仅设置width，不禁止缩放（不设置maximum-scale=1, minimum-scale=1），或者根本没有viewport的meta标签的情况下，浏览器会自动计算scale缩放值，使得整个页面显示在屏幕里面。 仅仅设置initial-scale时，首先会根据ideal设置visual，然后根据visual设置layout。如果设置initial-scale过小，layout也不会无限大，只会增大到某个和visual相等的值后不再变化。因此，这种方法设置的效果是layout和visual保持相等，也就不会出现滚动条。 当layout viewport的宽度大于visual viewport时，屏幕会出现滚动条（这种情况出现在缩放已指定，width宽度较大的时候）。所以一般缩放设置为1/dpr，即让layout的宽度（css宽度）为实际的屏幕像素数（水平方向），此时刚好1css像素等于1物理像素，且layout的宽度也等于visual的宽度。 如果设置width过大，可能导致layout &gt; visual ,出现滚动条。 用户手动缩放的时候，layout 和visual的宽度都不会变，变化的只是1pxCSS宽度所占据的物理像素个数，不用关心。 123456layout viewport = document.documentElement.clientWidthvisual viewport = window.innerWidth = ideal viewport / 当前缩放值 = ideal viewport * dpr//（说明了一旦缩放值固定，visual大小也就确定了）window.devicePixelRatio（dpr，设备决定的） = 物理像素/设备独立像素 （决定了一个css像素由几个物理像素渲染） viewport meta标签指令详解： viewport mata标签的每一对name/value都是一条指令。总共有6条指令： width： 用来设置layout viewport的宽度. initial-scale： 用来设置页面的初始缩放值以及layout viewport（和visual viewport）的宽度。 minimum-scale： 用来设置允许的最小缩放值(例如，用户可以缩小至什么程度)。 maximum-scale： 用来设置允许的最大缩放值(例如，用户可以放大至什么程度)。 height： 期望用于设置layout viewport的高度。但一直没被支持。 user-scalable： 当设置为no时，则禁止用户进行缩放。 在用户放大和缩小的过程中，visual viewport和layout viewport的宽，高都没发生任何的变化,变化的是css中的1px占据的物理像素数。 initial-scale 12345设置initial-scale指令，实际上完成了2件事情：1、设置了页面的初始缩放比例，根据相关的`ideal viewport`，生成对应的`visual viewport`宽度。2、根据刚刚计算出来的`visual viewport`宽度设置`layout viewport`的宽度。 常用移动端布局方案（精髓：保持元素所占比例不变） 流式布局方案 淘宝方案： data-dpr（处理字体） + rem（处理高宽等） 123456789101112131415161718192021222324252627282930313233343536373839404142431. 获取设备dpr，如果有的话2. 设置缩放为 1/dpr ，此时，layout=visual=物理宽度，所有屏幕下1px都对应1物理像素并且铺满屏幕不会出现滚动条 =&gt; 确定了 layout 宽度3. 设置 1rem 的尺寸:（要方便元素尺寸转换） 元素在设计稿中所占比例 = 元素高宽/设计稿宽度 = a/750 元素在layout中所占比例 = 目标高宽/layout = x/layout 令上述二者相等，有 a/750 = x/layout，x = layout * a/750 （px），接下来把px单位转换成rem单位，需要给rem设置一个px宽度 a、淘宝采取的是使用 layout/10 作为html的font-size（即1rem）： 当1rem = layout/10 时, 则 x = a/75 rem, b、网易采取的是使用 layout * 100/750 ： 当1rem = layout * 100/750 时，则 x = a/100 rem 让layout参与1rem组成的目的是，通过把layout抵消，在计算目标宽高时，不再需要考虑layout，只需把原始尺寸除以一个固定值就得到了以rem为单位的目标尺寸。 这样，不同设备对应不同的layout，也就产生了不同的1rem宽度。4. 元素的width/height，padding，margin，或图片等的大小做适配都要使用rem单位。5. 针对描述性的文本（大面积使用的）不使用rem，而是根据data-dpr来设置不同的符合点阵尺寸的px，如： div &#123; width: 1rem; height: 0.4rem; font-size: 12px; // 默认写上dpr为1的fontSize &#125; [data-dpr=&quot;2&quot;] div &#123; font-size: 24px; &#125; [data-dpr=&quot;3&quot;] div &#123; font-size: 36px; &#125;7. slogan型的文本可以使用rem8. 对于安卓设备，令dpr=1，即直接令layout=ideal=visual，后续步骤相同，这样的效果会不太精细。 网易方案：rem 1231. 设置layout为ideal宽度2. 设置1rem = layout * 100 / 750，则：目标元素的 rem 尺寸 = 原始 px 尺寸 / 100 两种方案的相同点：网易方案的设置 width=device-width 与淘宝方案在处理非 iOS 设备时让 dpr = 1，即 initial-scale = 1 的目的是相同的，都是让 layout = ideal = visual。然后在 layout中计算布局。 总结淘宝针对iOS设备做了专门处理，针对安卓与网易的方法一样。 https://macsalvation.net/2018/05/23/dive-into-viewport/","tags":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/tags/移动端/"}]},{"title":"性能优化","date":"2019-03-31T03:39:01.000Z","path":"2019/03/31/框架通识/性能优化/","text":"网络相关DNS预解析因为DNS的解析也是需要时间的，可以通过预解析方式来预先获得域名所对应的ip，此过程不会阻塞onload 1&lt;link rel=\"dns-prefetch\" href=\"//baidu.com\" /&gt; 缓存浏览器缓存分为强缓存和协商缓存 强缓存 通过两种响应头实现：Expires和Cache-Control。强缓存表示在缓存期间不需要请求，status code为200 1Expires: Wed, 22 Oct 2018 08:41:00 GMT Expires 是 HTTP / 1.0 的产物，表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。并且 Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。 1Cache-control: max-age=30 Cache-Control 出现于 HTTP / 1.1，优先级高于 Expires 。该属性表示资源会在 30 秒后过期，需要再次请求。 协商缓存 如果缓存过期了，我们就可以使用协商缓存来解决问题。协商缓存需要请求，如果缓存有效会返回 304。 协商缓存需要客户端和服务端共同实现，和强缓存一样，也有两种实现方式。 Last-Modified 和 If-Modified-SinceLast-Modified 表示本地文件最后修改日期，If-Modified-Since 会将 Last-Modified 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。 但是如果在本地打开缓存文件，就会造成 Last-Modified 被修改，所以在 HTTP / 1.1 出现了 ETag 。 ETag 和 If-None-MatchETag 类似于文件指纹，If-None-Match 会将当前 ETag 发送给服务器，询问该资源 ETag 是否变动，有变动的话就将新的资源发送回来。并且 ETag 优先级比 Last-Modified 高。 选择合适的缓存策略 对于某些不需要缓存的资源，可以使用 Cache-control: no-store ，表示该资源不需要缓存 对于频繁变动的资源，可以使用 Cache-Control: no-cache 并配合 ETag 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。 对于代码文件来说，通常使用 Cache-Control: max-age=31536000 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件。 HTTP/2.0因为浏览器有并发请求限制，在Http/1.1时代，每个请求都需要建立和断开，消耗了好几个RTT时间，并且由于TCP慢启动过程，加载体积大的文件会需要更多次RTT即更耗时。 在HTTP/2.0引入了多路复用，能让多个请求使用同一个TCP连接（注意与Http/1.1的connection：keep-alive的区别），并且支持Header压缩，服务端推送。 预加载预加载其实是声明式的 fetch ，强制浏览器请求资源，并且不会阻塞 onload 事件，可以使用以下代码开启预加载 1&lt;link rel=&quot;preload&quot; href=&quot;http://example.com&quot; /&gt; 预渲染可以通过预渲染将下载的文件预先在后台渲染，可以使用以下代码开启预渲染, 要确保预渲染的页面被打开，不然就是浪费资源 1&lt;link rel=&quot;prerender&quot; href=&quot;http://example.com&quot; /&gt; 优化渲染过程懒执行懒执行就是将某些逻辑延迟到使用时再计算，可以用于首屏优化，懒执行需要唤醒，可通过定时器或者事件机制。 懒加载懒加载就是将不关键的资源延后加载。 懒加载的原理就是只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西。对于图片来说，先设置图片标签的 src 属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为 src 属性，这样图片就会去下载资源，实现了图片懒加载。 懒加载不仅可以用于图片，也可以使用在别的资源上。比如进入可视区域才开始播放视频等等。 文件优化减少图片大小减少像素点 减少每个像素点能够显示的颜色 图片加载优化 不用图片 使用CDN加载 小图使用base64，虽然总大小增加，但可以减少网络请求 雪碧图 使用svg 其他文件优化 CSS 文件放在 head 中 服务端开启文件压缩功能 将 script 标签放在 body 底部，因为 JS 文件执行会阻塞渲染。当然也可以把 script 标签放在任意位置然后加上 defer ，表示该文件会并行下载，但是会放到 HTML 解析完成后顺序执行。对于没有任何依赖的 JS 文件可以加上 async ，表示加载和渲染后续文档元素的过程将和 JS 文件的加载与执行并行无序进行。 执行 JS 代码过长会卡住渲染，对于需要很多时间计算的代码可以考虑使用 Webworker。Webworker 可以让我们另开一个线程执行脚本而不影响渲染。 CDN静态资源尽量使用 CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 CDN 域名。对于 CDN 加载静态资源需要注意 CDN 域名要与主站不同，否则每次请求都会带上主站的 Cookie。 其他使用webpack 对于 Webpack4，打包项目使用 production 模式，这样会自动开启代码压缩 使用 ES6 模块来开启 tree shaking，这个技术可以移除没有使用的代码 优化图片，对于小图可以使用 base64 的方式写入文件中 按照路由拆分代码，实现按需加载 给打包出来的文件名添加哈希，实现浏览器缓存文件 监控通过window.onerror监控，通过img的src属性上报，异步错误使用try-catch","tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://yoursite.com/tags/性能优化/"}]},{"title":"框架比较","date":"2019-03-31T03:39:01.000Z","path":"2019/03/31/框架通识/框架比较/","text":"三大框架比较 Angular:（大而全） Angular是一个框架，而不是一个库，他是一个完整的解决方案，功能齐全。 适合较为复杂的SPA应用，比如工具类、OA类的应用。它属于大型框架，各个模块比较完整，提供的工具和拓展也比较丰富，适合沉淀大型项目，但上手成本高。并且原生依赖于typescript。 适合有Java等面向对象语言开发经验的程序员使用。 缺点：变动较快，兼容问题，并且以后可能会抛弃typescript转为dart。 React:（灵活） React是声明式，函数式的，适合对性能要求较高（v16.3引入了新的生命周期函数和fiber技术），且兼容移动端的产品（RN的应用比较广泛）。react‘更纯粹，更加自由，可控性更强’。html in js （注：fiber以render为界，划分两个阶段。可重复执行。） 学习曲线较陡峭，需要了解更多的JavaScript。 Vue:（小而快） 基于响应式的(HTML模板+VDOM)，适合增删改查类的管理系统，H5内嵌页，小程序之类的，改动频繁，综合成本较低。 Vue更加’自动化，智能’。js in html 模板—-使用html还是jsx，angular、vue把js放到html中，而react把html放到js中。 总结 面向对象，typescript =&gt; angular，ES6 =&gt; React，ES5/6 =&gt;Vue jsx还是html 框架还是UI库（angular无法直接添加到html中使用，因为它使用了typescript）。 状态管理和数据绑定 体积和性能 测试 原生开发：angular有ionic，react有RN 利用js渲染页面不利于SEO，因此有了服务端渲染 调试难易度，react和vue的黑魔法更少，找bug更容易。 心得新的框架常常能够引起我很多的思考，新的一些思想会冲击我，从不能接受到慢慢欣赏。同时学习和使用不同的框架能够相互促进，不建议二者好像只能取其一。就像多学习一门不同的语言，也能够体验更丰富的编程思想，最终能够融会贯通，提高自己。 HTML5新特性及使用 更多的语义化标签：，告别div+css 多媒体标签： input类型拓展：email，number，url，range，color，tel，date canvas,svg,webGL,CSS3的3D功能 localStorage,sessionStorage，IndexedDB（文档数据库，遵循同源策略） serviceWorker,webWorker,websocket 设备访问：geolocation 补充：Redux和MobX的区别两个库都提供了一种在组件外部管理应用程序状态的方法。状态与组件分离。组件可以访问状态，操作它（显式，隐式）并使用新状态进行更新。 Redux拥有单一store，且具有不可变性，只能通过reducer修改 MobX可以有多个store，且状态是可变的。 面试心得永远不要觉得面试官是在单纯的跟你聊天，他说的每句话都是有目的的，想好了再回答。技术不分高下，只有适用场景不同。慎言！","tags":[{"name":"框架比较","slug":"框架比较","permalink":"http://yoursite.com/tags/框架比较/"}]},{"title":"快排","date":"2019-03-31T03:39:01.000Z","path":"2019/03/31/算法/快排/","text":"思想：基于分治法，每次选定一个基准元素，目的是确定该基准元素的位置。实现比他大的放一侧，比它小的放一侧。 按步骤可以分为： 选定基准元素 找出基准元素位置 对基准元素两边的数据进行以上步骤 方法一：（简化版，浪费空间） 1234567891011121314151617function quickSort(arr)&#123; if(arr.length&lt;=1) return arr; let pivot = arr[0], left = [], right = []; // 依据pivot来分割数组 for(let i =0;i&lt;arr.length;i++)&#123; if(arr[i]&lt;pivot)&#123; left.push(arr[i]); &#125;else&#123; right.push(arr[i]); &#125; &#125; // 递归调用 return quickSort(left).concat([pivot], right);&#125; 方法二：（顺序扫描法） 参考：快速排序原理 123456789101112131415161718192021222324252627282930313233343536373839404142function quickSort(arr, left, right) &#123; if (arr.length &lt;= 1) return arr; left = typeof left === 'number' ? left : 0; right = typeof right === 'number' ? right : arr.length - 1; let partitionIndex; if (left &lt; right) &#123; partitionIndex = partition(arr, left, right); console.log(arr); quickSort(arr, left, partitionIndex - 1); quickSort(arr, partitionIndex + 1, right); &#125; return arr;&#125;function swap(arr, i, j) &#123; [arr[j], arr[i]] = [arr[i], arr[j]];&#125;function partition(arr, left, right) &#123; let pivot = arr[left], // 存储：指向小于pivot队列的末尾 storeIndex = left; for (let i = storeIndex + 1; i &lt;= right; i++) &#123; if (arr[i] &lt; pivot) &#123; // 注意：storeIndex始终指向小于pivot队列的末尾 // 要交换的是：使用后面小于pivot的值，换掉storeIndex指向的大于pivot的值 // index i // ↓ ↓ // 6 2 3 5 8 9 1 storeIndex++; if (arr[i] !== arr[storeIndex]) &#123; swap(arr, i, storeIndex); &#125; &#125; &#125; // 一趟结束，storeIndex指向分界点位置 swap(arr, left, storeIndex); return storeIndex;&#125; 方法三：（交换法） 12345678910111213141516function partition(arr, left, right) &#123; let pivot = arr[left], i = left, j = right; while (i &lt; j) &#123; // 从两头开始比较 停下来的时候交换 while (arr[j] &gt; pivot &amp;&amp; i &lt; j) j--; while (arr[i] &lt;= pivot &amp;&amp; i &lt; j) i++; // 交换前后 [arr[i], arr[j]] = [arr[j], arr[i]]; &#125; // 交换pivot [arr[left], arr[i]] = [arr[i], arr[left]]; return i;&#125;","tags":[{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/排序/"}]},{"title":"webpack打包结果分析","date":"2019-03-28T03:39:01.000Z","path":"2019/03/28/构建工具/webpack打包结果分析/","text":"webpack作用静态资源打包器，输出能在各种浏览器运行的代码，提升了开发至发布过程的效率。 简单配置配置文件是使用webpack的关键，一份配置文件主要包括：entry，output，mode，loader，plugin 工作原理（基于ES6的模块化的情况下） 打包结果 1234567(function(modules)&#123; // ...&#125;)(&#123; \"./src/index.js\": (function()&#123; // ... &#125;)&#125;); 整个文件只含一个立即执行函数，称为webpackBootstrap，它仅接收一个对象—–未加载的模块集合(modules), 这个modules对象的key是一个路径，value是一个函数。 webpackBootstrap函数体内部 1234567891011121314151617181920// webpackBootstrap(function(modules)&#123; // 缓存 __webpack_require__ 函数加载过的模块 var installedModules = &#123;&#125;; /** * Webpack 加载函数，用来加载 webpack 定义的模块 * @param &#123;String&#125; moduleId 模块 ID，一般为模块的源码路径，如 \"./src/index.js\" * @returns &#123;Object&#125; exports 导出对象 */ function __webpack_require__(moduleId) &#123; // ... &#125; // 在 __webpack_require__ 函数对象上挂载一些变量及函数 ... // 传入表达式的值为 \"./src/index.js\" return __webpack_require__(__webpack_require__.s = \"./src/index.js\");&#125;)(/* modules */); webpack_require函数内部实现 核心目的：把源文件变成一个module对象，存储module并返回module.exports 12345678910111213141516171819202122232425262728function __webpack_require__(moduleId) &#123; // 重复加载则利用缓存 if (installedModules[moduleId]) &#123; return installedModules[moduleId].exports; &#125; // 如果是第一次加载，则初始化模块对象，并缓存 var module = installedModules[moduleId] = &#123; i: moduleId, // 模块 ID l: false, // 模块加载标识 exports: &#123;&#125; // 模块导出对象 &#125;; /** * 执行模块 * @param module.exports -- 模块导出对象引用，改变模块包裹函数内部的 this 指向(充当this) * @param module -- 当前模块对象引用 * @param module.exports -- 模块导出对象引用 * @param __webpack_require__ -- 用于在模块中加载其他模块 */ modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); // 模块加载标识置为已加载 module.l = true; // 返回当前模块的导出对象引用 return module.exports;&#125; 模块执行函数 __webpack_require__ 中通过 modules[moduleId].call() 运行了模块执行函数，下面我们就进入到 webpackBootstrap 的参数部分，看看模块的执行函数。 1234567891011121314151617181920212223242526272829303132333435363738394041// webpackBootstrap(function(modules)&#123; // ...&#125;)(&#123; // 入口模块, 参数分别为：当前模块对象，导出对象，模块加载函数 \"./src/index.js\": (function(module, __webpack_exports__, __webpack_require__)&#123; \"use strict\"; // 用于区分 ES 模块和其他模块规范，不影响理解 demo，战略跳过。 __webpack_require__.r(__webpack_exports__); // 源模块代码中，`import &#123;plus, minus&#125; from './utils/math.js';` 语句被 loader 解析转化。 // 加载 \"./src/utils/math.js\" 模块，返回的是math.js的exports对象 /* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/math.js */ \"./src/utils/math.js\"); document.writeln('Hello webpack!'); // 把源文件中 plus(1, 2) 替换成 mathExports.plus(1, 2); document.writeln('1 + 2: ', Object(_utils_math_js__WEBPACK_IMPORTED_MODULE_0__[\"plus\"])(1, 2)); document.writeln('1 - 2: ', Object(_utils_math_js__WEBPACK_IMPORTED_MODULE_0__[\"minus\"])(1, 2)); &#125;), /*** 工具模块 ./src/utils/math.js ***/ \"./src/utils/math.js\": (function(module, __webpack_exports__, __webpack_require__) &#123; \"use strict\"; // 同 \"./src/index.js\" __webpack_require__.r(__webpack_exports__); // 源模块代码中，`export` 语句被 loader 解析转化。 // 导出 __webpack_exports__ /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"plus\", function() &#123; return plus; &#125;); /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"minus\", function() &#123; return minus; &#125;); const plus = (a, b) =&gt; &#123; return a + b; &#125;; const minus = (a, b) =&gt; &#123; return a - b; &#125;; &#125;)&#125;) 执行顺序是：入口模块 -&gt; 工具模块 -&gt; 入口模块。入口模块中首先就通过 __webpack_require__(“./src/utils/math.js”) 拿到了工具模块的 exports 对象。 导出模块webpack_require.d的实现 主要目的：把定义为导出的属性挂在exports对象上 ES 导出语法转化成了__webpack_require__.d(__webpack_exports__, [key], [getter])，而 __webpack_require__.d 函数的定义在 webpackBootstrap 内： 12345678910111213141516171819202122232425// 定义 exports 对象导出的属性。 __webpack_require__.d = function (exports, name, getter) &#123; // 如果 exports （不含原型链上）没有 [name] 属性，定义该属性的 getter。 // 为什么要用getter（形成闭包），而不是直接使用？？？ // Object.defineProperty(exports, name, &#123; // enumerable: true, // value: name // &#125;); // 答案：如果export一个非函数或class，则不会动态绑定 if (!__webpack_require__.o(exports, name)) &#123; Object.defineProperty(exports, name, &#123; enumerable: true, get: getter &#125;); &#125; &#125;; // 包装 Object.prototype.hasOwnProperty 函数。 __webpack_require__.o = function (object, property) &#123; // 注意：这种调用方式要比直接 obj.hasOwnProperty(key) 好得多，因为不用查找原型链 return Object.prototype.hasOwnProperty.call(object, property); &#125;;// ... 可见 __webpack_require__.d 其实就是 Object.defineProperty(obj, key, discriptor) 的简单包装（怪不得叫 d 呢）,区别就是前者的第三个参数不是一个描述对象，而是一个动态返回值得getter函数。 本文参考： 饿了么前端从webpack4打包文件说起","tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"react性能优化","date":"2019-03-23T03:39:01.000Z","path":"2019/03/23/React相关/react性能优化/","text":"React框架运行的原理：界面受到数据驱动，state 和 props 的改动会造成界面的改动。其中，state 是自身的属性，props 是父组件提供的参数。如果界面内容很多，很小的数据变化会造成界面的重绘，那么造成性能的浪费。下面从几个方面总结一下如何避免重新渲染。 Statestate是一个组件内部的属性。如果state变化，那么组件必然会 re-render。如果一个组件是静态单项组件（不涉及用户输入操作），避免 state 使用。如果界面中需要使用变量进行计算，可以使用属性（this.name）来代替state等。 如果不同 state 可以计算得出，直接计算推理，尽量减少 state 的数量。只有涉及用户交互的地方或者上下组件传值的地方才使用 state。 总之，state 越少越好。 Propsprops 是父组件向子组件传值的方式。如果父组件传递的 props 发生变化，那么子组件会重新渲染(取决于组件声明方式，class型默认shouldComponentUpdata返回true)。所以，为了比较起来方便，父组件传递的props可以优化，子组件需要什么，父组件再传递什么props。 Component组件化是react的重要思想。组件化不仅可以使得代码复用，同时可以优化性能。将界面上的功能区分成不同的组件。当某个数据发生变化，只更新一部分组件，其他组件不受影响，这样可以优化性能。 尽量使用无状态组件（数据由外部提供，内部没有用户数据交互行为等）。这部分组件就是单独的一部分，不受到外界的数据改变的影响。 生命周期函数生命周期函数需要熟记在心，使用react要时刻想到生命周期函数。 在 componentWillUpdate 和 componentDidUpdate 阶段，界面数据的处理可能会造成界面再次渲染。如果涉及递归等代码会造成很大的性能浪费。 在componentDidMount 阶段可以处理很多数据。 通过 shouldComponentUpdate 中判断，如果组件传来的props相同，那么返回 false 不需要进行界面重新渲染。前后不改变state值的setState（理论上）和无数据交换的父组件的重渲染都会导致组件的重渲染，但你可以在shouldComponentUpdate这道两者必经的关口阻止这种浪费性能的行为。 PureComponent React.PureComponent 的基础类可以对比props的差异。 immutable.js使用immutable.js 的不可变数据。","tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"react事件绑定和传参","date":"2019-03-20T03:39:01.000Z","path":"2019/03/20/React相关/react事件绑定和传参/","text":"一、事件绑定方式①在构造函数中绑定this,例如：1234constructor(props)&#123; super(props); this.pageGoto=this.pageGoto.bind(this); &#125; ②如果您使用实验性的 属性初始化语法，那么你可以使用属性初始值设置来正确地 绑定(bind) 回调：1234567891011121314class LoggingButton extends React.Component &#123; // 这个语法确保 `this` 绑定在 handleClick 中。 // 警告：这是 *实验性的* 语法。 handleClick = () =&gt; &#123; console.log('this is:', this); &#125; render() &#123; return ( &lt;button onClick=&#123;this.handleClick&#125;&gt; Click me &lt;/button&gt; ); &#125;&#125; ③箭头函数的方式：123&lt;button onClick=&#123;(e) =&gt; this.handleClick(e)&#125;&gt; Click me&lt;/button&gt; 这个语法的问题是，每次 LoggingButton 渲染时都创建一个不同的回调。在多数情况下，没什么问题。然而，如果这个回调被作为 prop(属性) 传递给下级组件，这些组件可能需要额外的重复渲染。我们通常建议在构造函数中进行绑定，以避免这类性能问题。 二、传参问题 单纯传递event对象，以下方式能良好工作： 12345678910// 方法一：（推荐） // 事件对象会作为最后一个参数隐式传递 deleteRow = (e) =&gt; &#123;&#125; &lt;button onClick=&#123;this.deleteRow&#125;&gt;Delete Row&lt;/button&gt;// 方法二： // 回调函数没有绑定this时 deleteRow(e)&#123; &#125; &lt;button onClick=&#123;(e) =&gt; this.deleteRow(id, e)&#125;&gt;Delete Row&lt;/button&gt; &lt;button onClick=&#123;this.deleteRow.bind(this)&#125;&gt;Delete Row&lt;/button&gt; 在循环内部，通常需要将一个额外的参数传递给事件处理程序。 例如，如果 id 是一个内联 ID，则以下任一方式都可以正常工作：（注：不建议在循环中定义回调，应使用事件代理） 123// 不管回调函数有没有绑定this，只要传递额外参数，都不外乎以下两种方式&lt;button onClick=&#123;(e) =&gt; this.deleteRow(id, e)&#125;&gt;Delete Row&lt;/button&gt;&lt;button onClick=&#123;this.deleteRow.bind(this, id)&#125;&gt;Delete Row&lt;/button&gt; 上述两行代码是等价的，分别使用 ·arrow functions和 Function.prototype.bind。 上面两个例子中，参数 e 作为 React 事件对象将会被作为第二个参数进行传递。 通过箭头函数的方式，事件对象必须显式的进行传递，但是通过 bind的方式，事件对象以及更多的参数将会被隐式的进行传递。","tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"react基础","date":"2019-03-20T03:39:01.000Z","path":"2019/03/20/React相关/react基础/","text":"React仅仅是一个视图层框架，并不具备数据流管理等功能。 React元素是不可变的，创建元素后，您无法更改其子元素或属性。元素就像电影中的单个帧：它代表特定时间点的UI。 一、更新UI的方法：1. ReactDOM.render(jsx, el);大多数ReactApp只调用一次ReactDOM.render方法。 2. 调用setState()方法二、函数(无状态)组件的封装任何一个可以返回jsx元素的函数都被称为一个无状态组件。它们只在初始化时被更新一次。用props.XXX获取传递进来的数据。 三、有状态组件的封装State类似于props，但它是私有的并且完全由组件控制。而local state仅适用于用class定义的组件。在class里面使用this.props.XXX获取。 在constructor里面初始化this.state=XXX 在生命周期方法内调用this.setState()更新视图 四、组件渲染过程参考React生命周期图： ReactDOM.render()方法会把传递进去的jsx进行解析，步骤包括： 组件初始化，执行constructor函数，接着调用componentWillMount钩子函数。不建议使用后者。 执行render方法，更新DOM 执行componentDidMount钩子函数 如果其中更改了state或者进行了别的会导致更新DOM的操作，会导致重新render。","tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"MessageChannel用法","date":"2019-03-18T03:39:01.000Z","path":"2019/03/18/JavaScript进阶/MessageChannel用法/","text":"使用方法 let channel = new MessageChannel(); 实例属性 channel.port1channel.port2 port1/2的方法 port1.postMessage()port1.onmessage(e=&gt;{e.data}) 简单来说，MessageChannel创建了一个通信的管道，这个管道有两个端口，每个端口都可以通过postMessage发送数据，而一个端口只要绑定了onmessage回调方法，就可以接收从另一个端口传过来的数据。 举个例子12345678let ch = new MessageChannel();const &#123;port1, port2&#125; = ch;port1.onmessage = (e)=&gt;console.log('port1 data:', e.data);port2.onmessage = (e)=&gt;console.log('port2 data:', e.data);port1.postMessage('i am port1');port2.postMessage('i am port2'); webWorker是一个独立的线程，它可以通过实例方法postMessage、onmessage和主线程页面通信。那么，有没有办法让多个webWorker互相通信呢？答案是肯定的，我们可以通过worker的postMessage实例方法将MessageChannel实例的port传递过去，通过port通信 12345678910111213141516171819202122232425262728// main.jslet w1 = new Worker(\"worker1.js\");let w2 = new Worker(\"worker2.js\");let ch = new MessageChannel();const &#123;port1,port2&#125; = ch;// 错误的方法: 因为port是只读的，不能被深拷贝过去用于通信w1.postMessage(port1);// 正确的做法：w1.postMessage(someObj, [port1]); // 第二个参数用于转移对象所有权，被转移后，在发送它的上下文中将变得不可用，并且只有在它被发送到的worker中可用。 w2.postMessage(someObj, [port2]); w2.onmessage(e=&gt;console.log(e.data)); // 观察worker2收到的数据// worker1.jsself.onmessage = (e)=&gt;&#123; const port1 = e.ports[0]; port.postMessage('send to worker2');&#125;// worker2.jsself.onmessage = (e)=&gt;&#123; const port2 = e.ports[0]; port2.onmessage(ms=&gt;&#123; self.postMessage(ms); // 因为worker线程不能使用console.log，因此需要把数据传回主线程打印观察 &#125;);&#125; 总结：消息传递路径为：worker1 =&gt; port1 =&gt; port2 =&gt; worker2","tags":[{"name":"JavaScript进阶","slug":"JavaScript进阶","permalink":"http://yoursite.com/tags/JavaScript进阶/"}]},{"title":"npm基础","date":"2019-03-16T03:39:01.000Z","path":"2019/03/16/构建工具/npm基础/","text":"package.json和package-lock.json package.json 1. 主要作用：记录npm install安装的包信息，定义一些工程描述信息等。 2. 常用字段意义说明1234567891011121314151617181920&#123; \"name\": \"blog\", //项目名称 \"version\": \"0.0.0\", //版本 \"description\": \"\", //项目描述 \"private\": true, \"main\": \"index.js\", //入口文件 \"scripts\": &#123; //配置一些通用的命令脚本 \"start\": \"node ./bin/www\" &#125;, \"keywords\": [], //项目的关键字 \"author\": \"\", //作者 \"dependencies\": &#123; //开发时的依赖 \"body-parser\": \"~1.16.0\" &#125;, \"devDependencies\": &#123; //运行时的依赖 \"express-session\": \"^1.15.1\" &#125;&#125;注：dependencies和devDependencies的区别在于，当执行npm install --production时，只会安装dependencies定义的依赖 3. 关于版本号规则版本格式： major.minor.patch =&gt; 主版本.次版本.修订版本 ^ 当指定minor时，minor不变，patch可向上增加；当仅指定major时，minor和patch可任意 12345如：~1.1.2，表示&gt;=1.1.2 &lt;1.2.0，可以是1.1.2，1.1.3，1.1.4，.....，1.1.n 如：~1.1，表示&gt;=1.1.0 &lt;1.2.0，可以是同上如：~1，表示&gt;=1.0.0 &lt;2.0.0，可以是1.0.0，1.0.1，1.0.2，.....，1.0.n，1.1.n，1.2.n，.....，1.n.n ~ 兼容某个版本，版本号中最左边的非0数字的右侧可以任意。如果缺少某个版本号，则这个版本号的位置可以任意 12345^1.2.3 := &gt;=1.2.3 &lt;2.0.0^0.2.3 := &gt;=0.2.3 &lt;0.3.0^0.0.3 := &gt;=0.0.3 &lt;0.0.4 4. 常用命令1234567891011121314151617npm init -y(--yes) // 初始化package.jsonnpm install (-g) (--save-dev / -D --save/-S) // 本地/全局安装npm uninstall （-g）packageName // 卸载本地/全局包npm root // 查看本地包位置npm root -g // 查看全局包位置npm update （-g） // 更新模块npm ls (-g) // 查看当前安装的模块（包）npm info //查看模块（包）的信息：npm cache verify // 清楚缓存 5. 切换npm源12345678//1.先安装nrm工具$ npm install -g nrm//2.查看当前可用的镜像源$ nrm ls//3.切换npm源$ nrm use 镜像源名称 package-lock.json { \"name\": \"china-telecom\", \"version\": \"1.0.0\", \"lockfileVersion\": 1, \"requires\": true, \"dependencies\": { \"set-value\": { \"version\": \"2.0.0\", \"resolved\": \"https://registry.npmjs.org/set-value/-/set-value-2.0.0.tgz\", \"integrity\": \"sha512-hw0yxk9GT/Hr5yJEYnHNKYXkIA8mVJgd9ditYZCe16ZczcaELYYcfvaXesNACk2O8O0nTiPQcQhGUQj8JLzeeg==\", \"dev\": true, \"requires\": { \"extend-shallow\": \"^2.0.1\", \"is-extendable\": \"^0.1.1\", \"is-plain-object\": \"^2.0.3\", \"split-string\": \"^3.0.1\" }, \"dependencies\": { \"extend-shallow\": { \"version\": \"2.0.1\", \"resolved\": \"https://registry.npmjs.org/extend-shallow/-/extend-shallow-2.0.1.tgz\", \"integrity\": \"sha1-Ua99YUrZqfYQ6huvu5idaxxWiQ8=\", \"dev\": true, \"requires\": { \"is-extendable\": \"^0.1.0\" } } } } } // 注意：requires和dependencies的区别： 假设包X依赖于Z1.0版中的包，而包Y依赖于相同的包Z，但是在2.0版中。在这种情况下，我们必须安装此软件包的两个版本。一个将安装在根node_modules文件夹中，另一个将安装在node_modules依赖包的文件夹中，例如 node_modules /X /Y /Z@2.0 /Z@1.0 有了这些知识，它很容易理解： “requires”反映了’package.json’文件中的依赖项，而“dependencies”反映了此依赖项的node_modules文件夹中实际安装的依赖项。 默认情况下，所有依赖项都安装在root node_modules中，但如果存在冲突，则它们将安装在该特定依赖项的node_modules中。 package.json里面定义的是版本范围（比如^1.0.0），具体跑npm install的时候安的什么版本，要解析后才能决定，这里面定义的依赖关系树，可以称之为逻辑树（logical tree）。 node_modules文件夹下才是npm实际安装的确定版本的东西，这里面的文件夹结构我们可以称之为物理树（physical tree）。 安装过程中有一些去重算法，所以你会发现逻辑树结构和物理树结构不完全一样。 package-lock.json可以理解成对结合了逻辑树和物理树的一个快照（snapshot），里面有明确的各依赖版本号，实际安装的结构，也有逻辑树的结构。其最大的好处就是能获得可重复的构建（repeatable build），当你在CI（持续集成）上重复build的时候，得到的artifact是一样的，因为依赖的版本都被锁住了。","tags":[{"name":"npm基础","slug":"npm基础","permalink":"http://yoursite.com/tags/npm基础/"}]},{"title":"webpack4.x代码分割","date":"2019-03-16T03:39:01.000Z","path":"2019/03/16/构建工具/webpack4.x代码分割/","text":"为什么要代码分割？ 它允许将代码拆分成多个捆绑的包，然后对这些包进行按需加载或者并行加载，使用得当可以达到首次加载速度的提成。 三种实现代码分割的通用方法，可以搭配使用 123451. 入口文件：通过手动配置多个webpack入口文件2. 避免重复: 使用splitChunks插件删除并提取出公共代码作为一个单独的chunk3. 动态导入：调用模块内的内联函数如import()或者require.ensure()异步加载代码 一、入口文件 最简单、最直观的代码分割方式，但缺陷也很明显 12345678// ...entry: &#123; //配置多个入口文件打包成多个代码块 index: path.resolve(root_path, &apos;index.js&apos;), a: path.resolve(root_path, &apos;a.js&apos;) &#125;, // ... 这样使得无关系的两个js模块可以并行加载，这种方式相比较于加载一个等价大小的js模块有速度上的提升。 但是也存在以下问题 1.如果index.js也引入了lodash，那么lodash将会同时打包到两个js模块中 2.不灵活，不能根据核心应用程序的逻辑来动态分割代码 二、避免重复 splitChunk插件（webpack4.x之前使用CommonsChunkPlugin）允许我们将公共依赖项提取到现有的entry chunk或全新的代码块中 适用场景：两个或多个独立的模块都使用了相同的第三方类库，此时就可以把该类库提取出来，这样，只下载一次就可以了。 splitChunk插件默认配置： 12345671. 模块被重复引用或者来自node_modules中的模块2. 在压缩前最小为30kb（即大于30kb才分割）3. 在按需加载时，请求数量小于等于5 （小于5才分割）4. 在初始化加载时，请求数量小于等于3 （小于3才分割） webpack使用SplitChunk插件： 12345optimization: &#123; splitChunks: &#123; chunks: 'all' &#125;&#125; 注意：xtract-text-webpack-plugin 已经被 mini-css-extract-plugin替代 三、动态导入webpack会自动分割动态导入的代码。 有两种方式供我们实现动态导入： 12341. import() // ES的提案，返回一个promise，导入的模块在then中拿到2. require.ensure() // webpack在编译时会静态的解析代码中的require.ensure(),将里面require的模块添加到一个分开的chunk中，这个新chunk会被webpack通过jsonp来按需加载。 下面主要使用import()实现动态导入，因为import()目前为止还是提案阶段，需要安装插件npm install babel-plugin-syntax-dynamic-import –save-dev，.babelrc配置如下 123456&#123; &quot;presets&quot;: [ ... ], &quot;plugins&quot;: [&quot;syntax-dynamic-import&quot;]&#125; 下面看核心代码 webpack.config.js：1234567891011121314151617181920212223var path = require(&apos;path&apos;);var root_path = path.resolve(__dirname);module.exports = &#123; mode: &apos;production&apos;, entry: &#123; index: path.resolve(root_path, &apos;index.js&apos;), &#125;, output: &#123; filename: &apos;[name].bundle.js&apos;, chunkFilename: &apos;[name].demand.js&apos;, path: path.resolve(root_path, &apos;dist&apos;) &#125;, module: &#123; rules: [ &#123; test: /\\.js$/, loader: &apos;babel-loader&apos;, exclude: path.resolve(root_path, &apos;node_modules&apos;), include: root_path &#125; ] &#125;&#125; index.js：点击按钮才异步加载lodash 1234567891011121314let btn = document.getElementById(&apos;btn&apos;);btn.addEventListener(&apos;click&apos;, () =&gt; &#123; import(/* webpackChunkName: &quot;lodash&quot; */ &apos;lodash&apos;).then( _ =&gt; &#123; var app = document.getElementById(&apos;app&apos;); app.textContent = _.join([&apos;Index&apos;, &apos;Module&apos;, &apos;Loaded!&apos;], &apos; &apos;); &#125; ).catch( err =&gt; &#123; console.log(&apos;loading module error occur&apos;, err); &#125; )&#125;); chunkFilename：采用注释的写法指定非entry chunk的文件名，比如import()引入的模块不打包进entry中，而会作为单独的chunk打包，其文件名就由该属性决定 链接：https://www.jianshu.com/p/3c93c0e724ba。","tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"Symbol相关","date":"2019-02-16T03:39:01.000Z","path":"2019/02/16/JavaScript进阶/Symbol相关/","text":"参考：Symbol相关 ES6引入了Symbol类型，即js中的第7种数据类型引入目的：每个从Symbol()返回的symbol值都是唯一的。一个symbol值能作为对象属性的标识符；这是该数据类型仅有的目的。symbol分为全局和布局，分别用Symbol.for()和Symbol()产生，不支持new, 一般都使用局部的12345var a=Symbol(\"a\"), b=Symbol(\"a\");a === b; //falsevar a = Symbol.for(\"a\"), b = Symbol.for(\"a\");a === b; //true Symbol类型的key一般情况下不会被遍历到，除非使用Object.getOwnPropertySymbols();因此可以做到隐藏私有属性如何通过symbol隐藏私有属性？ 首先，私有属性的key都用symbol去设置 然后，不对外暴漏产生这些symbol的声明，可以通过闭包实现，因为在闭包外部访问不到内部的声明 12345678910111213// 隐藏了私有属性namevar People = (function() &#123; var name = Symbol(\"name\"); class People &#123; constructor(n) &#123; //构造函数 this[name] = n; &#125; sayName() &#123; console.log(this[name]); &#125; &#125; return People;&#125;)();","tags":[{"name":"JavaScript进阶","slug":"JavaScript进阶","permalink":"http://yoursite.com/tags/JavaScript进阶/"}]},{"title":"ES Module","date":"2019-01-17T03:45:56.000Z","path":"2019/01/17/ES6/ES Module/","text":"import {***} from “abcd”;表示从最近的node_modules里面找 import {***} from “./abcd”;表示按相对路径找 export 后面跟着的语句需要具有声明部分和赋值部分。 声明部分为export提供了所暴露接口的标识 赋值部分为export提供了接口的值 12345export const apiRoot = &apos;fsalfjslfj&apos;;export function method()&#123;&#125;export class Foo&#123;&#125; 默认导出不需要声明部分 1export default &lt;value&gt;","tags":[{"name":"ES6，ES7新特性","slug":"ES6，ES7新特性","permalink":"http://yoursite.com/tags/ES6，ES7新特性/"}]},{"title":"ES6 新特性","date":"2019-01-17T03:45:56.000Z","path":"2019/01/17/ES6/ES6 新特性/","text":"1. 新增let、const命令 let：声明一个变量 不会变量提升，存在暂时性死区，因此以前声明在{… …}里面的变量改用let声明后并不会提升到函数作用域或者全局作用域，实际上也就形成了块级作用域。 有了块级作用域后，广泛使用的立即执行函数(function(){… …})();已经不需要了。 暂时性死区的本质: 只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。 ES5规定只能在全局或者函数环境下声明函数。ES6中，在块级作用域里也可以声明的函数。只是函数声明语句类似于let，不能在块级作用域外使用。 但是在支持ES6的浏览器中，在块级作用域中声明函数类似于var，即会提升到全局作用域或者函数作用域的头部。同时函数声明还会提升到所在的块级作用域的头部。 因使用环境差异导致块级作用域解析不一致，所以应尽量避免在块级作用域中声明函数，如果确实需要，应写成函数声明表达式。 const：声明一个常量 一旦声明，就必须初始化，且声明后常量的值就不能变。 作用域问题同let const 实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。 2. ES6声明变量的6种方法： 在ES5中，声明变量只有var和function两种方法 ES6中，增加了let、const、import、class四种 3. 在全局环境使用let和const声明的变量不再是全局对象的属性，仅仅只是全局变量。4. 数组和对象的解构本质：属于模式匹配使用场景：主要用在变量赋值和函数传参中 数组：只要某种数据具备Iterator接口，都可以使用数组的解构。 12345678910111213141516let [a,b,c] = [1,2,3];let [,,c] = [1,2,3];let [a,b,...c] = [1,2,3,4,5]; // c: [3,4,5]解构不成功的值为undefined，展开操作符得到的是空数组let [a,b,c,...d] = [1]; // b,c:undefined d:[]let [x, y, z] = new Set([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]);数组解构允许指定默认值let [foo = true] = []; // foo:truelet [b,c = 2] = [1]; // c:2判断一个位置是否有值，是使用(XXX === undefined)的：let [x = 1] = [undefined]; // x = 1let [x = 1] = [null]; //x = null 对象；对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。 123456789101112let &#123; foo, bar &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;; // foo: &quot;aaa&quot; bar: &quot;bbb&quot;let &#123; foo: baz &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;; // baz: &quot;aaa&quot;// foo: error: foo is not defined// 也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。注意，采用这种写法时，变量的声明和赋值是一体的。对于 let 和 const 来说，变量不能重新声明，所以一旦赋值的变量以前声明过，就会报错。let foo;let &#123;foo&#125; = &#123;foo: 1&#125;; // SyntaxError: Duplicate declaration &quot;foo&quot;let baz;let &#123;bar: baz&#125; = &#123;bar: 1&#125;; // SyntaxError: Duplicate declaration &quot;baz 5. 展开运算符1. 当展开运算符(…args)出现在函数的最后一个参数（也可以是唯一一个）时，起到合并实参到一个名为args的数组中的作用。2. 其他情况： 数组的展开： let arr1 = [1,2,3],arr2 = [4,5,6]; let arr3 = […arr1,…arr2];let arr3 = […[1,2,3], …[4,5,6]]; 对象的展开： let obj1 = {key1: 1}, obj2 = {key2:2}; let obj3 = {…obj1, …obj2}; 6. Promise Promise是一种异步流程控制手段。 Promise的构造函数接收一个函数（Excutor）作为参数 Excutor接收两个函数，resolve和reject，可以在Excutor体内主动调用。 new Promise之后，Excutor函数会立即执行 每一个promise的实例上都会有一个then方法，有两个参数，一个成功的回调，一个失败的回调 then中如果返回的是promise，会取这个promise的结果，传递到下一个then里面。如果返回的是值，这个值会直接传递到下一个then的onfulfilled。如果没有显式return，则给下一个then的onfulfilled传递undefined。 then中如果返回promise，并不是返回了this，而是返回了一个新的promise。 可以使用catch统一处理来自Excutor或者来自then的错误和异常。 Promise.all([prom1,prom2]).then(([res1,res2])=&gt;{})，并发发出多个异步请求，只有在所有都成功时，then才成功，有任何一个失败，都会走then的失败。 Promise.race([])，并发发出多个请求，第一个成功或者失败的会进入then。 解决回调地狱的方法：在一个then里面返回一个新的promise，就可以把嵌套的promise改成链式调用的。","tags":[{"name":"ES6，ES7新特性","slug":"ES6，ES7新特性","permalink":"http://yoursite.com/tags/ES6，ES7新特性/"}]},{"title":"Promise详解","date":"2019-01-17T03:45:56.000Z","path":"2019/01/17/ES6/Promise详解/","text":"作用异步解决方案。 使用方法:核心思想：通过异步事件自己主动调用resolve，reject方法驱动then的执行123456789let promise1 = new Promise(function(resolve,reject)&#123; if(dosomething)&#123; resolve(some); &#125;else&#123; reject(other); &#125;&#125;);promise1.then(res=&gt;&#123;&#125;,rej=&gt;&#123;&#125;); 实现构造函数的实现123456789101112131415161718192021222324252627282930function MyPromise(excutor)&#123; let self = this; self.status = 'pending'; self.data = undefined; // 存放每一个then里面的回调函数 self.resolveCallbacks = []; self.rejectCallbacks = []; function resolve(data)&#123; // 调了resolve方法之后，status才会变成resolved if(self.status === 'pending')&#123; self.status = 'resolved'; self.data = data; // 执行then里面的onfulfilled回调 self.resolveCallbacks.forEach(func=&gt;func(self.data)); &#125; &#125; function reject(reason)&#123; if(self.status === 'pending')&#123; self.status = 'rejected'; // 调了reject方法之后，status才会变成rejected self.data = reason; // 执行then里面的onRejected回调 self.resolveCallbacks.forEach(func=&gt;func(self.data)); // 才会执行then里面的回调 &#125; &#125; try&#123; excutor(resolve,reject); &#125;catch(e)&#123; reject(e); &#125;&#125; then的实现1. then也是一个函数，它接受两个函数参数。因此promise的执行过程为：121. 先执行new：在这个过程中，传递给构造函数的excutor会被立即执行，返回一个可以被thenable的promise对象2. 如果这个promise对象跟着的有then方法，那么在then(res=&gt;&#123;&#125;,rej=&gt;&#123;&#125;)的时候就执行了then方法，并不是类似事件监听机制，而是纯粹的函数执行。then的执行过程见下面then的实现。 2. 由于可以多次then，且promise的状态一旦改变就不能再次改变，因此每次then要返回一个新的promise。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152MyPromise.prototype.then = function(onFulfilledCall, onRejectedCall)&#123; let self = this; // 根据标准，如果then的参数不是function，则我们需要忽略它，实现透明传输，以如下方式补上带有return的回调（手工return） onFulfilledCall = typeof onFulfilledCall === 'function' ? onFulfilledCall : val=&gt;val; onRejectedCall = typeof onRejectedCall === 'function' ? onRejectedCall : err=&gt;throw err; // 如果当前的promise状态已经resolve，此时再then，则then里面的onFulfilled回调函数立即获取到值并执行 if(self.status === 'resolved')&#123; // then方法的返回值，返回一个新的promise return promise2 = new MyPromise(function(resolve, reject)&#123; // 为了保证then的顺序执行，这里用setTimeout包裹回调的执行 setTimeout(()=&gt;&#123; // 因为考虑到有可能throw，所以我们将其包在try/catch块里 try&#123; let x = onFulfilledCall(self.data); // 因为then的回调函数执行结果可能是一个普通值，也可能是一个promise，需要分开处理 // 当x为普通值时，直接将x作为promise2成功（then）的结果，此次then结束。 // 当x为一个promise时，将x的结果（成功/失败）作为promise2成功/失败的结果 // 目的是保证当前then完全结束后，才继续后面的then // resolvePromise(promise2,x,resolve,reject); &#125;catch(e)&#123; reject(e); &#125; // resolve(x); 因为x不确定类型，因此这里不能直接resolve &#125;,0) &#125;) &#125; // 如果当前的promise状态已经reject，此时再then，则then里面的OnRejected回调函数立即获取到值并执行 if(self.status === 'rejected')&#123; return promise2 = new MyPromise(function(resolve, reject)&#123; // 因为考虑到有可能throw，所以我们将其包在try/catch块里 try&#123; let x = onRejectedCall(self.data); resolvePromise(promise2,x,resolve,reject); &#125;catch(e)&#123; reject(e); &#125; // reject(x); &#125;) &#125; // 如果当前的Promise还处于pending状态，此时来个then，我们并不能确定调用onResolved还是onRejected， // 只能等到Promise的状态确定后，才能确实如何处理。 // 所以我们需要把我们的**两种情况**的处理逻辑做为callback放入promise1(此处即this/self)的回调数组里 // 逻辑本身跟第一个if块内的几乎一致，此处不做过多解释 if(self.status === 'pending')&#123; return promise2 = new Promise(function(resolve, reject) &#123; // 之所以不直接push(onFulfilledCall),同样是因为onFulfilledCall的执行结果可能是一个promise，这时需要单独处理，因此不能简单的push(onFulfilledCall) self.resolveCallbacks.push(function()&#123; // 因为考虑到有可能throw，所以我们将其包在try/catch块里 try&#123; let x = onFulfilledCall(self.data); resolvePromise(promise2,x,resolve,reject); &#125;catch(e)&#123; reject(e); &#125; //resolve(x); &#125;); self.rejectCallbacks.push(function()&#123; // 因为考虑到有可能throw，所以我们将其包在try/catch块里 try&#123; let x = onRejectedCall(self.data); resolvePromise(promise2,x,resolve,reject); &#125;catch(e)&#123; reject(e); &#125; //reject(x); &#125;); &#125; &#125;&#125;// 用于处理x和promise2的关系: function resolvePromise(promise2,x,resolve)&#123; // 不能自己等待自己成功或者失败 if(x === promise2)&#123; return reject(new TypeError('Chaining cycle')); &#125; let called; // x为对象，则看它是不是具有then方法 if(x !== null &amp;&amp; (typeof x === 'object' || typeof x === 'function'))&#123; try&#123; // 为了防止有人通过defineProperty定义then，且在getter里面抛出异常(即取then时报异常)，因此需要try...catch let then = x.then; if(typeof then === 'function')&#123; // x是个可以then的promise，取它的结果 then.call(x, rs=&gt;&#123; if(called) return； called = true; resolvePromise(promise2,rs,resolve,reject); // 取x的成功结果rs，继续进行判断 &#125;,err=&gt;&#123; if(called) return; called = true; reject(err); // 取x的失败结果，直接拒绝，不再继续判断 &#125;) &#125;else&#123; resolve(x); // x是个具有then属性而不是then方法的对象 &#125; &#125; &#125;else&#123; resolve(x); // x为普通值，直接resolve &#125;&#125;// 为了下文方便，我们顺便实现一个catch方法Promise.prototype.catch = function(onRejected) &#123; // 默认不写成功的接收 return this.then(null, onRejected)&#125; // reject方法Promise.reject = function(reason)&#123; return new Promise((resolve,reject)=&gt;&#123; reject(reason); &#125;)&#125;// resolve方法Promise.resolve = function(value)&#123; return new Promise((resolve,reject)=&gt;&#123; resolve(value); &#125;)&#125;// Promise.all方法Promise.all = function(promises)&#123; return new Promise((resolve,reject)=&gt;&#123; let arr = []; promises.forEach((promise,index)=&gt;&#123; promise.then(data=&gt;&#123; arr.push(data); if(index === promise.length-1)&#123; // 全部返回后才resolve resolve(arr); &#125; &#125;) &#125;) &#125;)&#125;// Promise.racePromise.race = function(promises)&#123; return new Promise((resolve,reject)=&gt;&#123; promises.forEach((promise,index)=&gt;&#123; promise.then( // 错误的方法，因为此时的resolve和reject方法是promise的（执行时确定），而不是return的那个promise的 /*data=&gt;&#123; resolve(data); &#125;,reason=&gt;&#123; reject(reason); &#125;*/ // 正确的方法,需要调用外层return的promise的resolve和reject方法（作为参数传递）（这俩一旦被调用就表明promise有结果了，并且promise的成功/失败值会自动传入给resolve，reject方法） resolve,reject ) &#125;) &#125;)&#125;","tags":[{"name":"ES6，ES7新特性","slug":"ES6，ES7新特性","permalink":"http://yoursite.com/tags/ES6，ES7新特性/"}]},{"title":"babel","date":"2019-01-17T03:45:56.000Z","path":"2019/01/17/ES6/babel/","text":"babel是一个转码器，可以将ES6代码转换成ES5代码，从而在现有环境执行。 babel-cli：babel的命令行转码工具 babel-core：转换新的语法 babel-pollify：转换新的api，如：Array.prototype.from()","tags":[{"name":"ES6，ES7新特性","slug":"ES6，ES7新特性","permalink":"http://yoursite.com/tags/ES6，ES7新特性/"}]},{"title":"css基础","date":"2019-01-17T03:27:06.000Z","path":"2019/01/17/CSS/css基础/","text":"常用单位： 绝对单位：px 相对单位：em，rem em：1em与当前元素的字体大小相同（默认16px），有继承性，依赖父元素。 rem：同em，只是相对于根元素（html{ font-size：16px；}，初始化）。 vw，vh：分别是视口宽度的1/100和视口高度的1/100。 百分比 终保持其父元素的百分比。父元素没设置宽度的情况下，向上追溯到元素，默认情况下是视口宽度的100％。 省略单位的情况： { margin: 0; } { font-size: 16px; line-height: 1.5; } 颜色： 关键词：red，white … 十六进制：#AABBCC，一对十六进制表示一个颜色通道，分别为红绿蓝。（注意：#556677 可以简写为 #567） RGB：通过rgb(0-255，0-255，0-255)函数指定颜色，分别对应红绿蓝。 HSL：该hsl()函数接受的色相、饱和度以及明度值。 色相：颜色的底色调。这个值在0到360之间，表示色轮周围的角度 饱和度：饱和度是多少？需要一个从0-100%的值，其中0是没有颜色（它将显示为灰色），100%是全彩色饱和度。 明度值：颜色有多亮或明亮？这需要一个从0-100%的值，其中0是无光（它会出现全黑的），100%是充满光的（它会出现全白）。 RGBA和HSLA： alpha通道。0是完全透明的,1是完全不透明的。 不透明度（Opacity） 取值为0-1 注意与alpha的区别：opacity应用于整个元素，包括背景色及文本。而alpha不影响文本。 css的层叠和继承 什么选择器在层叠中胜出取决于三个因素（这些都是按重量级顺序排列的——前面的的一种会否决后一种）： 重要性（Importance） 专用性（Specificity） 源代码次序（Source order） 专用性: 它能匹配多少元素 ! important &gt; ID选择器 &gt; 类选择器 计算规则继承： 对 font-family 和 color 进行继承是有意义的 margin、padding等不继承 控制继承：四种通用属性 inherit： 该值将应用到选定元素的属性值设置为与其父元素一样。 initial ：该值将应用到选定元素的属性值设置为与浏览器默认样式表中该元素设置的值一样。如果浏览器默认样式表中没有设置值，并且该属性是自然继承的，那么该属性值就被设置为 inherit。 unset ：该值将属性重置为其自然值，即如果属性是自然继承的，那么它就表现得像 inherit，否则就是表现得像 initial。 revert ：如果当前的节点没有应用任何样式，则将该属性恢复到它所拥有的值。换句话说，属性值被设置成自定义样式所定义的属性（如果被设置）， 否则属性值被设置成用户代理的默认样式。 盒模型 mozilia讲的好 盒子宽度不包括外边距（想象真实世界的箱子） 垂直方向的外边距塌陷问题 更改默认盒模型：box-border：border-box | content-box（默认值） | padding-box 高级框操作 overflow auto: 当内容过多，溢流的内容被隐藏，然后出现滚动条来让我们滚动查看所有的内容。 hidden: 当内容过多，溢流的内容被隐藏。 visible: 当内容过多，溢流的内容被显示在盒子的外边（这个是默认的行为） 背景裁剪（background-clip): 设置元素的背景（背景图片或颜色）是否延伸到边框下面。 border-box 背景延伸到边框外沿（但是在边框之下）。 padding-box 边框下面没有背景，即背景延伸到内边距外沿。 content-box 背景裁剪到内容区 (content-box) 外沿。 text 背景被裁剪为文字的前景色(只有chrome支持)。 轮廓(Outline) 一个框的 outline 是一个看起来像是边界但又不属于框模型的东西。它的行为和边界差不多，但是并不改变框的尺寸（更准确的说，轮廓被勾画于在框边界之外，外边距区域之内） 常用布局 浮动布局： 两列浮动布局：百分比width + float 三列浮动布局 多列浮动布局 绝对定位: 定位的参照物是其包含块,一个元素的包含块是由其最近的 position 为 absolute / relative / fixed 的祖先元素决定的(即：position非static)。如果没有找到，则为初始包含块（以整个 canvas (渲染内容的空间, http://www.w3.org/TR/CSS2/intro.html#canvas) 的坐标原点(左上)为基准，以 viewport (也就是浏览器视窗内渲染 HTML 的空间)为大小的矩形。）。 元素定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框。配合z-index使用。 相对定位：元素的位置相对于它在普通流中的位置 固定定位（相对视口）","tags":[{"name":"css常用","slug":"css常用","permalink":"http://yoursite.com/tags/css常用/"}]},{"title":"css3渐变","date":"2019-01-17T03:27:06.000Z","path":"2019/01/17/CSS/css3渐变/","text":"本文整理自MDN 渐变适用范围 CSS linear-gradient() 函数用于创建一个表示两种或多种颜色线性渐变的图片。其结果属于数据类型，是一种特别的数据类型。 由于数据类型系的子数据类型，只能被用于可以使用的地方。因此，linear-gradient() 并不适用于background-color以及类似的使用 数据类型的属性中。 渐变种类 线性渐变 linear-gradient() 径向渐变 radial-gradient() 重复渐变 repeating-linear-gradient()、 repeating-radial-gradient() 渐变使用方法 线性渐变 线性渐变相关概念： 渐变线：渐变线由包含渐变图形的容器的中心点和一个角度来定义的。渐变线上的颜色值是由不同的点来定义，包括起始点，终点，以及两者之间的可选的中间点（中间点可以有多个）。 起始点：起始点是渐变线上代表起始颜色值的点。起始点由渐变线和过容器顶点的垂直线之间的交叉点来定义。（垂直线跟渐变线在同一象限内） 终点：终点是渐变线上代表最终颜色值的点。终点也是由渐变线和从最近的顶点发出的垂直线之间的交叉点定义的，然而从起始点的对称点来定义终点是更容易理解的一种方式，因为终点是起点关于容器的中心点的反射点。 线性渐变的构成：渐变线轴上的每个点都具有独立的颜色。为了构建出平滑的渐变，linear-gradient() 函数构建一系列垂直于渐变线的着色线，每一条着色线的颜色则取决于与之垂直相交的渐变线上的色点 简单线性渐变(最终语法)： linear-gradient([ [ [ | to [top | bottom] || [left | right] ],]? [, ]+); 解释一下：角度和to ×× 可选且只选其一，颜色终点必选且允许有多个；颜色终点可选跟一个表示距离的指定长度或者百分比，形式为：color1 距离1，color2 距离2；距离指的是color所在渐变线上的点与起始点的距离（不是坐标）。 参考：深入理解线性渐变 关于角度的使用： 带有浏览器前缀的（-webkit和-moz）：使用极坐标定义参数，导致了0deg指向东方，且顺时针方向角度增加。 不带有前缀的，W3C标准：与CSS的其他部分保持一致，将0deg指向北方，且顺时针方向角度增加。 chrome下，缺省角度时，默认为180deg，即从上到下。 如果指定的前后两个color-stop与渐变线方向相反，即后者距离小于前者时，后者的距离失效，且整体失去渐变效果。 如果两个color-stop构成的区间α位于[start,end]之间，则在α区间内呈现渐变效果，在α之外保持与临近端点相同颜色。 径向渐变–待整理","tags":[{"name":"css常用","slug":"css常用","permalink":"http://yoursite.com/tags/css常用/"}]},{"title":"css的省略号不能在table中工作的解决办法","date":"2019-01-17T03:27:06.000Z","path":"2019/01/17/CSS/css的省略号不能在table中工作的解决办法/","text":"参考：https://stackoverflow.com/questions/10372369/why-doesnt-css-ellipsis-work-in-table-cell 示例： HTML：12345&lt;table&gt; &lt;tbody&gt; &lt;tr&gt;&lt;td&gt;Hello Stack Overflow&lt;/td&gt;&lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; CSS：1234567td &#123; border: 1px solid black; width: 50px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;&#125; JS：123$(function() &#123; console.log(&quot;width = &quot; + $(&quot;td&quot;).width());&#125;); 输出为：width = 139，并且不显示省略号。 原因分析： 使用overflow的前提：overflow，width，display，和white-space。 而th、td默认为display: table-cell。 不完美解决方案： 更改th、td的display为block 123th，td &#123; display: block; /* or inline-block */&#125; 对table使用table-layout: fixed;。但失去了对列宽的控制。 12345678910table &#123; width: 100%; table-layout: fixed; // 表格列宽平均分配容器宽度&#125;td &#123; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;&#125; 最佳解决方案：1234567891011121314table &#123; width: 100%;&#125;// 将你的文本包装成一个&lt;div&gt;并将你的CSS应用到&lt;div&gt;,而不是&lt;td&gt;th, td &gt; div &#123; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;&#125;// 此时可以指定列宽,注意!!! 如果使用循环模板，注意给每一个元素都设置同样的大小，调样式时也必须同时更改所有元素宽度才可以！// th可以不管，他会自适应，只改td就行。[th,] td &#123; max-width:100px; &#125;","tags":[{"name":"css常用","slug":"css常用","permalink":"http://yoursite.com/tags/css常用/"}]},{"title":"css盒模型和宽度计算","date":"2019-01-17T03:27:06.000Z","path":"2019/01/17/CSS/css盒模型和宽度计算/","text":"css盒模型和宽度计算盒模型： 每个元素都被表示成一个矩形的盒子，这个模型描述了元素所占空间的内容。 每个盒子都有四个边：外边距边，边匡边，内填充边，内容边。正如打开chrome的调试模式下，右下角的图一样，为一个盒模型。 默认情况下（w3c规范），元素的宽度只是包含content-box区域。但这个元素在屏幕上占据的空间仍然还是border以内的部分。 关于宽度计算： 在css中，设置一个元素的width和height只会应用到这个元素的内容区，如果这个元素有任何的border或padding，绘制到屏幕上时的盒子宽度和高度会加上设置的边框和内边距值。 box-sizing用于更改计算元素宽度和高度的默认的盒子模型。 content-box是默认值，指内容区的宽度。任何边框和内边距都会被增加到最后绘制出来的元素中。这意味着当你调整一个元素的宽度和高度时需要时刻注意到这个元素的边框和内边距，在实现响应式布局时，很麻烦。 border-box告诉浏览器，你设置的边框和内边距的值是包含在width内的。内容区的实际宽度会是width减去border+padding的值。这个时候，只要设置统一宽度100%，然后就可以在里面随意修改border和padding了。 padding-box是被废弃的api，尽量不要使用。","tags":[{"name":"css常用","slug":"css常用","permalink":"http://yoursite.com/tags/css常用/"}]},{"title":"opacity、visibility、overflow、display的联系和区别","date":"2019-01-17T03:27:06.000Z","path":"2019/01/17/CSS/opacity、visibility、overflow、display的联系和区别/","text":"区别和作用12345678910111213141516171819201. display:none该方式让元素隐藏时，隐藏的元素不占空间，隐藏后将改变html原有样式。即会导致回流和重绘，降低性能。2. visibility:hidden该方式让元素隐藏时，隐藏的元素还是占用原有位置，隐藏后不将改变html原有样式。但，如果该元素的子元素使用了visibility:visible的话，改子元素将不被隐藏。3. opacity:0 该方式让元素隐藏时，隐藏的元素还是占用原有位置，隐藏后不将改变html原有样式。但，隐藏的元素所对应的事件，仍然可以触发。 4. overflow: hidden该方式把超出容器的部分全部切掉，即超出的部分不仅不显示，而且也不占据空间。通过overflow和height也能达到彻底隐藏一个元素的目的 height：0； overflow：hidden；","tags":[{"name":"css常用","slug":"css常用","permalink":"http://yoursite.com/tags/css常用/"}]},{"title":"三栏布局","date":"2019-01-17T03:27:06.000Z","path":"2019/01/17/CSS/三栏布局/","text":"三栏布局的常用做法1. flex思想：左右两列定宽，中间flex-grow: 1 优点：中间盒子的文本不被左右覆盖，高度统一 缺点：没有中间盒子优先渲染 补充：flex容器和flex子项常用属性：1234567容器：&#123; display: flex|inline-flex;（块元素和行元素皆可flex） flex-flow: row|row-reverse|column|column-reverse;(默认：row nowrap) wrap|nowrap|wrap-reverse; justify-content: flex-start|center|flex-end|space-between|space-around;（主轴对齐方式） align-items: flex-start|center|flex-end|space-between|space-around;（交叉轴对齐方式） align-content: 多根轴线对齐时使用&#125; 12345678910子项：&#123; order: 数值越小越靠前，默认为0 /* flex-grow: 放大比例，默认为0（不放大）。如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 flex-shrink: 缩小比例，默认为1（缩小）。如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 flex-basis: 在分配多余空间之前，项目占据的主轴空间。 */ flex: 以上三者的合并，默认值为 flex: 0 1 auto; align-self: 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。&#125; 2. float思想：左右两边设置固定宽度，而且分别设置 float:left和right，这个方法有一个需要注意的是在HTML中，中间栏需要和右边栏进行对调（利用浮动元素不占据块空间的特性）； 缺点！！！ 这样做的原理是，浮动元素“浮”在了中间非浮动盒子的两端。此时，中间盒子仍然是铺满整行的，可以通过观察它的背景色看到这点，只是它的行空间（比如文本）被浮动元素占据，挤到了中间。并且没有中间优先渲染。不推荐。 3. absolute思想：左右两边设置固定宽度和 position:absolute,而且分别设置 left: 0和 right: 0，中间栏只要设置左右margin为左右栏的宽度就可以了（需要注意的是左右两边需要设置 top: 0，不然右边会被顶下来） 缺点：存在三者高度不统一问题 优点：中间盒子的文本不被左右覆盖，可以实现中间优先渲染 4. 圣杯布局（推荐）思想： 全浮动+中间with100%+负边距，为了解决中间盒子文本被左右覆盖的问题，给父容器设置左右padding，给左右盒子设置定位分别左右移动。 优点：中间盒子的文本不被左右覆盖，中间优先渲染，高度统一 5. 双飞翼布局（推荐）思想：全浮动+中间with100%+负边距，为了解决中间盒子文本被左右覆盖的问题，给中间盒子增加一个具有左右外边距的div作为真实容器。 优点：中间盒子的文本不被左右覆盖，中间优先渲染，高度统一","tags":[{"name":"css常用","slug":"css常用","permalink":"http://yoursite.com/tags/css常用/"}]},{"title":"伪元素和伪类的使用","date":"2019-01-17T03:27:06.000Z","path":"2019/01/17/CSS/伪元素和伪类的使用/","text":"伪元素的使用 伪元素包括first-letter、first-line、before、after, first-letter用于向文本的第一个字母添加特殊样式。 first-line用于向文本的第一行添加特殊样式 before、after用于在一个元素的前、后添加一个”虚假的元素“。这个元素不会显示在DOM结构中，因此合理的使用可以减小DOM开支。 为了与伪类区分，使用element::before,element::after，注意伪元素/伪类与宿主元素选择器之间没有空间。 凡是遇到要给宿主元素添加某种宿主元素本身无法直接用css属性直接实现的特性，都应该优先考虑伪元素,尤其是制作某些css3特效时。 伪元素与伪类和选择器可以自由搭配使用。如： .class-1:hover::after .class-2::after:hover .class-3:hover .class::after input标签是个特殊情况，它并不支持伪元素。设置了也不会有任何效果。因为能设置伪元素的前提是宿主元素是一个容器，即能包含其他元素。显然，input、img、iframe不是容器。因此，给input美化的时候不考虑使用after等。 伪元素的content属性是必须的，不然不会有任何东西出现。 content: normal|string|attr()|url()|counter()|none 总结 before时，content的内容会插在主元素内容部分的开始处 after时，content的内容会插在主元素内容部分的结尾处 当主元素没有内容时before与after仍会正常工作，属性为inline元素，若需要设置高宽度等属性需要display：block;。 position为absolute的伪元素的定位参照不一定是宿主元素了，而是最近的已定位父元素。一般把主元素设为relative，伪元素absolute，方便定位。 参考：css伪元素用法大全","tags":[{"name":"css常用","slug":"css常用","permalink":"http://yoursite.com/tags/css常用/"}]},{"title":"常用css","date":"2019-01-17T03:27:06.000Z","path":"2019/01/17/CSS/常用css/","text":"常用css 父元素设置的padding 可以由子元素设置的-margin抵消掉； 尽量用百分比表示高宽； box-shadow: h-shadow v-shadow blur spread color inset; 让图片自适应父div宽度，令img的width和height都为100%； 为了隐藏一个元素，同时不占据文档空间，可以设置scale(0) + opacity: 0; div内垂直居中一行里面的若干行元素：给div设置固定高度，且等于line-height。子元素line-height为100%。所有box-sizing设置为border-box。","tags":[{"name":"css常用","slug":"css常用","permalink":"http://yoursite.com/tags/css常用/"}]},{"title":"inline元素巧用","date":"2019-01-17T03:27:06.000Z","path":"2019/01/17/JavaScript基础/inline元素巧用/","text":"inline、block、inline-block的区别inline: inline元素不会独占一行，多个相邻的行内元素会排列在同一行里，直到一行排列不下，才会新换一行，其宽度随元素的内容而变化。 inline元素设置width,height属性无效。 inline元素的margin和padding属性，水平方向的padding-left, padding-right, margin-left, margin-right都产生边距效果；但竖直方向的padding-top, padding-bottom, margin-top, margin-bottom不会产生边距效果。 block: block元素会独占一行，多个block元素会各自新起一行。默认情况下，block元素宽度自动填满其父元素宽度。 block元素可以设置width,height属性。块级元素即使设置了宽度,仍然是独占一行。 block元素可以设置margin和padding属性。 inline-block： 简单来说就是将对象呈现为inline对象，但是对象的内容作为block对象呈现。之后的内联对象会被排列在同一行内。比如我们可以给一个link（a元素）inline-block属性值，使其既具有block的宽度高度特性又具有inline的同行特性。 inline-block元素的巧用 在使用bootstrap的网格系统时，当给一个块元素设置了小于100%的width后，会给父容器(col-x-x)右侧留下一段空间，当然，我们可以使用margin: 0 auto;来让这个不满width的block居中，同时还可以通过对该block设置display: inline-block,从而达到自动缩小该block的宽度 巧用inline-block做列表布局 参考：巧用inline-block做列表布局 123456&lt;ul&gt; &lt;li&gt;someBlock&lt;/li&gt; &lt;li&gt;someBlock&lt;/li&gt; &lt;li&gt;someBlock&lt;/li&gt; &lt;li class=\"fix\"&gt;someBlock&lt;/li&gt;&lt;/ul&gt; 123456789101112131415ul&#123; padding: 20px; font-size: 0; li&#123; display: inline-block; width: 100px; padding: 0 10px; vertical-align: top; // 顶端对齐 text-align: justify; // 段落文本（行元素）两端对齐 list-style: none; font-size: 16px; box-sizing: border-box; &#125;&#125; 注意：列表（或文字）要两端对齐的前提就是内容必须超过一行，最后一行显然不满一行，因此没有效果。要解决最后一行列表无法两端对齐其实也很简单，就是在列表的最后创建一个高度为0的宽度100%的透明的inline-block的标签层就可以： 123456li.fix&#123; overflow: hidden; width: 100%; height: 0; padding: 0;&#125; 注意：当元素display属性是inline-block时，元素之间在换行显示或空格分隔的情况下会有间距，为了去掉这个间距，可以使用以下方法： 移除元素间的空格 无需闭合标签 使用margin负值,margin负值的大小与上下文的字体和文字大小相关，目前这里的字体大小是默认的16px，所以设置了-4px的间隙就可以了，那如果换种字体以及字体大小就又不行了，所以这个方法也不是很完美 给父元素使用font-size: 0;，然后在子标签里面重设font-size即可。","tags":[{"name":"css常用","slug":"css常用","permalink":"http://yoursite.com/tags/css常用/"}]},{"title":"spring依赖注入原理","date":"2019-01-17T01:45:58.000Z","path":"2019/01/17/Java/spring依赖注入原理/","text":"前言： JavaBean： 即POJO的同义词 Spring通过应用上下文（ Application Context） 装载bean的定义并把它们组装起来。 Spring应用上下文全权负责对象的创建和组装。 Spring自带了多种应用上下文的实现， 它们之间主要的区别仅仅在于如何加载配置。 spring通过依赖注入和面向接口实现松耦合 传统的做法：每个对象负责管理与自己相互协作的对象的引用。 spring的做法：在类中定义依赖关系，然后通过配置，在运行时实例化（new）这些依赖。即：spring干的活就是根据定义好的依赖关系，使用相应的bean构造方法，将构造好的bean（实例化的对象）注入描述依赖的地方。 spring装配bean的三种方式：一、 在XML中进行显式配置。 创建Bean： 补充：内部调用该class的无参构造函数创建对象 装配Bean： 构造器注入： 引用类型注入： 字面量注入： 集合注入： 1234567891011121314&lt;constructor-arg&gt; &lt;list&gt; &lt;value&gt;****&lt;/value&gt; &lt;value&gt;****&lt;/value&gt; ... ... &lt;/list&gt;==========================或者 &lt;set&gt; &lt;value&gt;****&lt;/value&gt; &lt;value&gt;****&lt;/value&gt; ... ... &lt;/set&gt;&lt;/constructor-arg&gt; setter方法属性注入： 注入引用类型： 补充：通过setter方法注入的 注入字面量： 注入集合： 12345&lt;property name=&quot;&quot;&gt; &lt;list&gt; &lt;value&gt;...&lt;/value&gt; &lt;/list&gt;&lt;/property&gt; 二、在Java中进行显式配置。 创建Bean：给一个返回对象的方法加上@Bean注解 装配Bean： 在需要其他Bean的时候引用创建那个Bean的方法 使用@AutoWired注解，可以放在任何能使用@AutoWired注解的地方 补充：（自动单例：看起来， CompactDisc是通过调用sgtPeppers()得到的，但情况并非完全如此。因为sgtPeppers()方法上添加了@Bean注解，Spring将会拦截所有对它的调用，并确保直接返回该方法所创建的bean，而不是每次都对其进行实际的调用。） 三、隐式的bean发现机制和自动装配（注解+组件扫描+自动装配） 创建bean：容器会自动把扫描到的带有注解的类实例化 装配bean：@AutoWired注解，容器自动装配 关于注入方式，即Bean的注入地点：共有三种 构造器注入； 设值注入（setter方式注入）； Feild方式注入（字段方式注入）。 使用哪种方式？ 强依赖使用构造器注入 弱依赖使用setter注入 不会动态修改某个bean本身的时候，使用Feild注入。","tags":[{"name":"Spring详解","slug":"Spring详解","permalink":"http://yoursite.com/tags/Spring详解/"}]},{"title":"HTTPS","date":"2019-01-17T01:45:58.000Z","path":"2019/01/17/http/HTTPS/","text":"OSI七层协议模型和TCP/IP协议模型： HTTPS：也称作HTTP over TLS。 SSL/TLS: 安全套接字/传输层安全 它提供的服务主要有： 认证用户和服务器，确保数据发送到正确的客户机和服务器； 加密数据以防止数据中途被窃取； 维护数据的完整性，确保数据在传输过程中不被改变。 属于哪一层？ =&gt;答案是：在OSI七层模型中，它属于第五层（会话层）和第六层（表示层）；在TCP/IP协议中，对应于应用层。 它不执行“寻址”，因为它使用已建立的TCP连接，在其之上创建（加密）会话。因此会把它放在第4层（传输层）之上的会话层。 从它的功能来看，TLS和SSL属于加密应用层数据的级别，对应于表示层。 图解： 传输层传递的是数据段，应用层是完整报文。?? 错！！！=&gt;传递的都是字节码,文本在保存的时候，保存的是字节码。打开的时候，使用选定的解码方式转换成字符。 在发送已加密的http报文之前，客户端和服务器要进行一次ssl握手，在这个握手过程中，他们要完成以下工作： 交换协议版本号 选择一个两端都了解的密码 对两端的身份进行认证 生成临时的会话密钥，以便加密信道 http和https事务： TLS握手过程: 单向认证和双向认证: 单向认证： 客户端向服务器发送消息，服务器接到消息后，用服务器端的密钥库中的私钥对数据进行加密，然后把加密后的数据和服务器端的公钥一起发送到 客户端，客户端用服务器发送来的公钥对数据解密，然后再用传到客户端的服务器公钥对数据加密传给服务器端，服务器用私钥对数据进行解密，这就完成了客户端 和服务器之间通信的安全问题，但是单向认证没有验证客户端的合法性。 双向认证： 客户端向服务器发送消息，首先把消息用客户端证书加密然后连同时把客户端证书一起发送到服务器端。 服务器接到消息后用首先用客户端证书把消息解密，然后用服务器私钥把消息加密，把服务器证书和消息一起发送到客户端。 客户端用发来的服务器证书对消息进行解密，然后用服务器的证书对消息加密，然后在用客户端的证书对消息在进行一次加密，连同加密消息和客户端证书一起发送到服务器端， 到服务器端首先用客户端传来的证书对消息进行解密，确保消息是这个客户发来的，然后用服务器端的私钥对消息在进行解密这个便得到了明文数据。 细节部分 握手过程使用非对称加密 通信过程使用对称加密 公钥加密，私钥解密 更详细的HTTPS工作原理=&gt; HTTPS工作原理","tags":[{"name":"http、https","slug":"http、https","permalink":"http://yoursite.com/tags/http、https/"}]},{"title":"http常用概念总结","date":"2019-01-17T01:45:58.000Z","path":"2019/01/17/http/http常用概念总结/","text":"TCP/IP 或者SOCKET传输的是以字节表示(即二进制)的数据包。一个字节8个bit，4bit用一个16进制数表示，刚好一个字节两位16进制表示。 HTTP请求头和响应头都是以ASCII文本方式传输的，但传输的内容可以是多样的，服务端根据请求头中的content-type字段来获得请求中的消息主体是用何种方式编码，再对主体进行解析。所以说到POST提交数据方案，包含了Content-Type和消息主体编码两部分。 参考：POST提交数据详解 一、HTTP方法HTTP/1.1协议规定的HTTP请求方法有OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT这几种。其中POST一般用来向服务端提交数据，本文主要讨论POST提交数据的几种方式。 1.application/x-www-form-urlencode浏览器的原生表单，如果不设置enctype属性，那么最终就会以application/x-www-form-urlencoded方式提交数据。1234POST http://www.example.com HTTP/1.1Content-Type: application/x-www-form-urlencoded;charset=utf-8title=test&amp;sub%5B%5D=1&amp;sub%5B%5D=2&amp;sub%5B%5D=3 首先，Content-Type 被指定为 application/x-www-form-urlencoded；其次，提交的数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL 转码。大部分服务端语言都对这种方式有很好的支持。 很多时候，我们用 Ajax 提交数据时，也是使用这种方式。例如 JQuery 和 QWrap 的 Ajax，Content-Type 默认值都是「application/x-www-form-urlencoded;charset=utf-8」。 2. multipart/form-data这又是一个常见的 POST 数据提交的方式。我们使用表单上传文件时，必须让 表单的 enctype 等于 multipart/form-data。直接来看一个请求示例： 12345678910111213POST http://www.example.com HTTP/1.1Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA------WebKitFormBoundaryrGKCBY7qhFd3TrwAContent-Disposition: form-data; name=&quot;text&quot;title------WebKitFormBoundaryrGKCBY7qhFd3TrwAContent-Disposition: form-data; name=&quot;file&quot;; filename=&quot;chrome.png&quot;Content-Type: image/pngPNG ... content of chrome.png ...------WebKitFormBoundaryrGKCBY7qhFd3TrwA-- 这个例子稍微复杂点。首先生成了一个 boundary 用于分割不同的字段，为了避免与正文内容重复，boundary 很长很复杂。然后 Content-Type 里指明了数据是以 multipart/form-data 来编码，本次请求的 boundary 是什么内容。消息主体里按照字段个数又分为多个结构类似的部分，每部分都是以 –boundary 开始，紧接着是内容描述信息，然后是回车，最后是字段具体内容（文本或二进制）。如果传输的是文件，还要包含文件名和文件类型信息。消息主体最后以 –boundary– 标示结束。 这种方式一般用来上传文件，各大服务端语言对它也有着良好的支持。 上面提到的这两种 POST 数据的方式，都是浏览器原生支持的，而且现阶段标准中原生 表单也只支持这两种方式（通过 元素的 enctype 属性指定，默认为 application/x-www-form-urlencoded。其实 enctype 还支持 text/plain，不过用得非常少）。 3. application/jsonapplication/json 这个 Content-Type作为响应头大家肯定不陌生。实际上，现在越来越多的人把它作为请求头，用来告诉服务端消息主体是序列化后的 JSON 字符串。由于 JSON 规范的流行，除了低版本 IE之外的各大浏览器都原生支持 JSON.stringify，服务端语言也都有处理 JSON 的函数，使用 JSON 不会遇上什么麻烦。 JSON 格式支持比键值对复杂得多的结构化数据，这一点也很有用。记得我几年前做一个项目时，需要提交的数据层次非常深，我就是把数据 JSON 序列化之后来提交的。不过当时我是把 JSON 字符串作为 val，仍然放在键值对里，以 x-www-form-urlencoded 方式提交。(比使用纯粹的json字符串+application/json的提交方式适用性更广)。 Google 的 AngularJS 中的 Ajax 功能，默认就是提交 JSON 字符串。例如下面这段代码： 1234var data = &#123;&apos;title&apos;:&apos;test&apos;, &apos;sub&apos; : [1,2,3]&#125;;$http.post(url, data).success(function(result) &#123; ...&#125;); 最终发送的请求是： 1234POST http://www.example.com HTTP/1.1 Content-Type: application/json;charset=utf-8&#123;&quot;title&quot;:&quot;test&quot;,&quot;sub&quot;:[1,2,3]&#125; 这种方案，可以方便的提交复杂的结构化数据，特别适合 RESTful 的接口。各大抓包工具如 Chrome自带的开发者工具、Firebug、Fiddler，都会以树形结构展示 JSON数据，非常友好。但也有些服务端语言还没有支持这种方式，例如 php 就无法通过 $_POST 对象从上面的请求中获得内容。这时候，需要自己动手处理下：在请求头中 Content-Type 为 application/json 时，从 php://input 里获得原始输入流，再 json_decode 成对象。一些 php 框架已经开始这么做了。 当然 AngularJS 也可以配置为使用 x-www-form-urlencoded 方式提交数据。 二、表单提交实战当前台提交的数据只是纯粹的key-value时，可以使用默认的application/x-www-urlencode编码方式123456let data = &#123; \"key1\":\"value1\", \"key2\":\"value2\", \"key3\":\"value3\",&#125;let data = \"key1=1&amp;key2=2&amp;key3=3\" 当前台提交的数据里面包含复杂类型，比如：数组、对象等, 有以下两种方式1. 使用application/json + 序列化的json1234567let data = &#123; \"key1\":[1,2,3], \"key2\":\"value2\", \"key3\":&#123; \"key33\": 4 &#125;,&#125; 后端接收； 1//后台设置一个结构等同于前台提交数据的model类，去接收数据 2. 使用multipart/form-data12345let formData = new FormData();// FormData 只能接收string和blob类型的数据// 所以要传递数组或者json对象的话，也需要先序列化成字符串formData.append('key1',JSON.stringify(&#123;key1:1&#125;));formData.append('key2',file); 后端接收； 1234String dataStr = request.getParameter(\"key1\");JSONObject obj = JSONObject(dataStr);// 当然，也可以设置一个只含String和MultipartFile的model类去接收 3. 把要发送的json字符串作为value，仍然使用x-www-urlencode方法123456789let data = &#123; \"key1\":[1,2,3], \"key2\":\"value2\", \"key3\":&#123; \"key33\": 4 &#125;,&#125;;let dataStr = JSON.stringify(data);&gt; &amp;data=dataStr 后端接收； 12String dataStr = request.getParameter(\"data\");JSONObject obj = JSONObject(dataStr);","tags":[{"name":"http、https","slug":"http、https","permalink":"http://yoursite.com/tags/http、https/"}]},{"title":"长连接，短连接？","date":"2019-01-17T01:45:58.000Z","path":"2019/01/17/http/http长连接、短连接？/","text":"参考：长连接/短连接？ HTTP1.0协议不支持长连接，从HTTP1.1协议以后，连接默认都是长连接。HTTP协议是基于请求/响应模式的，因此只要服务端给了响应，本次HTTP连接就结束了，或者更准确的说，是本次HTTP请求就结束了，根本没有长连接这一说。那么自然也就没有短连接这一说了。 第一个问题是，是不是只要设置Connection为keep-alive就算是长连接了？ 当然是的，但要服务器和客户端都设置。 第二个问题是，我们平时用的是不是长连接？ 这个也毫无疑问，当然是的。（现在用的基本上都是HTTP1.1协议，你观察一下就会发现，基本上Connection都是keep-alive。而且HTTP协议文档上也提到了，HTTP1.1默认是长连接，也就是默认Connection的值就是keep-alive） 第三个问题，也是LZ之前最想不明白的问题，那就是我们这种普通的Web应用（比如博客园，我的个人博客这种）用长连接有啥好处？需不需要关掉长连接而使用短连接？ 这个问题LZ现在终于明白了，问题的答案是好处还是有的。 好处是什么？ 首先，刚才已经说了，长连接是为了复用，这个在之前LZ就明白。那既然长连接是指的TCP连接，也就是说复用的是TCP连接。那这就很好解释了，也就是说，长连接情况下，多个HTTP请求可以复用同一个TCP连接，这就节省了很多TCP连接建立和断开的消耗。 比如你请求了博客园的一个网页，这个网页里肯定还包含了CSS、JS等等一系列资源，如果你是短连接（也就是每次都要重新建立TCP连接）的话，那你每打开一个网页，基本要建立几个甚至几十个TCP连接，这浪费了多少资源就不用LZ去说了吧。 但如果是长连接的话，那么这么多次HTTP请求（这些请求包括请求网页内容，CSS文件，JS文件，图片等等），其实使用的都是一个TCP连接，很显然是可以节省很多消耗的。 这样一解释，就很明白了，不知道大家看了这些解释感觉如何，反正LZ在自己想明白以后，有种豁然开朗的感觉。 另外，最后关于长连接还要多提一句，那就是，长连接并不是永久连接的。如果一段时间内（具体的时间长短，是可以在header当中进行设置的，也就是所谓的超时时间），这个连接没有HTTP请求发出的话，那么这个长连接就会被断掉。 这一点其实很容易理解，否则的话，TCP连接将会越来越多，直到把服务器的TCP连接数量撑爆到上限为止。现在想想，对于服务器来说，服务器里的这些个长连接其实很有数据库连接池的味道，大家都是为了节省连接重复利用嘛，对不对？ 长轮询和短轮询前面基本上LZ已经把长短连接说的差不多了，接下来说说长短轮询，今天也正是为了研究长短轮询，LZ才顺便研究了下长短连接这回事。 短轮询相信大家都不难理解，比如你现在要做一个电商中商品详情的页面，这个详情界面中有一个字段是库存量（相信这个大家都不陌生，随便打开淘宝或者京东都能找到这种页面）。而这个库存量需要实时的变化，保持和服务器里实际的库存一致。 这个时候，你会怎么做？ 最简单的一种方式，就是你用JS写个死循环，不停的去请求服务器中的库存量是多少，然后刷新到这个页面当中，这其实就是所谓的短轮询。 这种方式有明显的坏处，那就是你很浪费服务器和客户端的资源。客户端还好点，现在PC机配置高了，你不停的请求还不至于把用户的电脑整死，但是服务器就很蛋疼了。如果有1000个人停留在某个商品详情页面，那就是说会有1000个客户端不停的去请求服务器获取库存量，这显然是不合理的。 那怎么办呢？ 长轮询这个时候就出现了，其实长轮询和短轮询最大的区别是，短轮询去服务端查询的时候，不管库存量有没有变化，服务器就立即返回结果了。而长轮询则不是，在长轮询中，服务器如果检测到库存量没有变化的话，将会把当前请求挂起一段时间（这个时间也叫作超时时间，一般是几十秒）。在这个时间里，服务器会去检测库存量有没有变化，检测到变化就立即返回，否则就一直等到超时为止。 而对于客户端来说，不管是长轮询还是短轮询，客户端的动作都是一样的，就是不停的去请求，不同的是服务端，短轮询情况下服务端每次请求不管有没有变化都会立即返回结果，而长轮询情况下，如果有变化才会立即返回结果，而没有变化的话，则不会再立即给客户端返回结果，直到超时为止。 这样一来，客户端的请求次数将会大量减少（这也就意味着节省了网络流量，毕竟每次发请求，都会占用客户端的上传流量和服务端的下载流量），而且也解决了服务端一直疲于接受请求的窘境。 但是长轮询也是有坏处的，因为把请求挂起同样会导致资源的浪费，假设还是1000个人停留在某个商品详情页面，那就很有可能服务器这边挂着1000个线程，在不停检测库存量，这依然是有问题的。 因此，从这里可以看出，不管是长轮询还是短轮询，都不太适用于客户端数量太多的情况，因为每个服务器所能承载的TCP连接数是有上限的，这种轮询很容易把连接数顶满。之所以举这个例子，只是因为大家肯定都会网购，所以这个例子比较通俗一点。 哪怕轮询解决不了获取库存这个问题，但只要大家明白了长短轮询的区别，这就足够了。实际上，据LZ自己平日里购物的观察，那个库存量应该是不会变的，这个例子纯属LZ个人的意淫，-_-。 长短轮询和长短连接的区别这里简单说一下它们的区别，LZ这里只说最根本的区别。 第一个区别是决定的方式，一个TCP连接是否为长连接，是通过设置HTTP的Connection Header来决定的，而且是需要两边都设置才有效。而一种轮询方式是否为长轮询，是根据服务端的处理方式来决定的，与客户端没有关系。 第二个区别就是实现的方式，连接的长短是通过协议来规定和实现的。而轮询的长短，是服务器通过编程的方式手动挂起请求来实现的。","tags":[{"name":"http、https","slug":"http、https","permalink":"http://yoursite.com/tags/http、https/"}]},{"title":"jQuery不支持获取响应头里面的location字段","date":"2019-01-17T01:45:58.000Z","path":"2019/01/17/http/jQuery不支持获取响应头里面的location字段/","text":"jQuery不支持获取响应头里面的location字段使用场景：前天使用ajax访问一个没有权限的接口时，服务器返回302，并且用location重定向到指定页面。于是，在回调中这么写了：123success: function(data, status, xhr)&#123; window.location.href = xhr.getResponseHeader('Location');&#125; 然而，并没有预期效果，调试发现，xhr.getResponseHeader(&#39;Location&#39;)的输出是null。查资料得知，jQuery给出的xhr并不能获取到location字段。 解决方案： 另行设置一个自定义响应头，在xhr里面获取。 使用原生XmlHttpRequest，通过xhr.responseUrl获取。","tags":[{"name":"http、https","slug":"http、https","permalink":"http://yoursite.com/tags/http、https/"}]},{"title":"二进制、字节码、字符","date":"2019-01-17T01:45:58.000Z","path":"2019/01/17/http/二进制、字节码、字符/","text":"首先明确，在计算机中，一切数据的最终存在形式都是0110…，显然，人类没法直接阅读这种信息。 因此，就要出现编码。 所谓编码就是按照一定的规则，将那些二进制翻译成人类能看懂的字符。 首先考虑现实生活有多少种字符需要表示，同时还需要一些控制字符，加起来一共127个（参见ASCII码表），如果要对以二进制表示的字符进行区分，至少得7位。考虑到精简性、未来可拓展性，因此规定8个比特位表示一个字节。 所谓字节，也就是翻译二进制的最小单位。 12345ASCII码：一个英文字母（不分大小写）占一个字节的位置，一个中文汉字占两个字节的位置。UTF-8编码：一个英文字符等于一个字节，一个中文（含繁体）等于三个字节。Unicode编码：一个英文等于两个字节，一个中文（含繁体）等于两个字节。符号：英文标点占一个字节，中文标点占两个字节。 同时，规定存储器的最小存储单元为一个字节。 一根地址线可以传输0/1两个状态，因此可以连接两个存储单元，二根地址线可以表示4种状态，三根可以表示8种…,n根可以表示2^n个地址空间。 因此，32位cpu可以最大支持 2^32 个地址空间，每个空间为1B（byte），因此可支持4GB内存；同理，64位可支持2^64B = 2^54KB = 2^44GB = 2^34TB","tags":[{"name":"http、https","slug":"http、https","permalink":"http://yoursite.com/tags/http、https/"}]},{"title":"跨域cors与options","date":"2019-01-17T01:45:58.000Z","path":"2019/01/17/http/跨域cors与options/","text":"CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨源服务器发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。参考：cors详解 一 、简介CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。 整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。 因此，实现CORS通信的关键是服务器。只要服务器（目标服务器，非同源服务器）实现了CORS接口，就可以跨源通信。 浏览器将CORS分为两类：简单请求和非简单请求1. 简单请求：同时满足以下两大条件 请求类型是HEAD、GET、POST 可人为设置的HTTP的头信息不超出以下几种字段（其他首部自动默认标准设置，如：host、User-Agent等） Accept Accept-Language Content-Language Content-Type：（只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain） 2. 凡是不同是满足以上条件的都是非简单请求简单请求的处理：对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。 下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个Origin字段。123456GET /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。 如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。 如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。 Access-Control-Allow-Origin: http://api.bob.com Access-Control-Allow-Credentials: true Access-Control-Expose-Headers: FooBar Content-Type: text/html; charset=utf-8 上面的头信息之中，有三个与CORS请求相关的字段，都以Access-Control-开头。 （1）Access-Control-Allow-Origin 该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。 （2）Access-Control-Allow-Credentials 该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。 （3）Access-Control-Expose-Headers 该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值。 XMLHttpRequest的withCredentials 属性 上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。1Access-Control-Allow-Credentials: true 另一方面，开发者必须在AJAX请求中打开withCredentials属性。12var xhr = new XMLHttpRequest();xhr.withCredentials = true; 否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。但是，如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭withCredentials。1xhr.withCredentials = false; 需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。 非简单请求处理1. 预检请求对于一些put、delete请求，或者content-type为application/json等的非简单跨域请求，浏览器会自动发出一个“预检”请求，要求服务器确认可以这样做。比如：12345678OPTIONS /cors HTTP/1.1Origin: http://api.bob.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... “预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。 除了Origin字段，”预检”请求的头信息包括两个特殊字段。 （1）Access-Control-Request-Method 该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。 （2）Access-Control-Request-Headers 该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。 2. 预检请求的回应服务器收到”预检”请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。12345678910111213// 注意：Request变成了AllowHTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderContent-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain 上面的HTTP回应中，关键的是Access-Control-Allow-Origin字段，表示http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。1Access-Control-Allow-Origin: * 如果浏览器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。12XMLHttpRequest cannot load http://api.alice.com.Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin. 服务器回应的其他CORS相关字段如下。1234Access-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderAccess-Control-Allow-Credentials: trueAccess-Control-Max-Age: 1728000 （1）Access-Control-Allow-Methods 该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。 （2）Access-Control-Allow-Headers 如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。 （3）Access-Control-Allow-Credentials 该字段与简单请求时的含义相同。 （4）Access-Control-Max-Age 该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。 3. 浏览器的正常请求和回应一旦服务器通过了”预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。 下面是”预检”请求之后，浏览器的正常CORS请求。1234567PUT /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comX-Custom-Header: valueAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 上面头信息的Origin字段是浏览器自动添加的。 下面是服务器正常的回应。12Access-Control-Allow-Origin: http://api.bob.comContent-Type: text/html; charset=utf-8 上面头信息中，Access-Control-Allow-Origin字段是每次回应都必定包含的。","tags":[{"name":"http、https","slug":"http、https","permalink":"http://yoursite.com/tags/http、https/"}]},{"title":"计算机网络工作原理","date":"2019-01-17T01:45:58.000Z","path":"2019/01/17/计算机网络/计算机网络工作原理/","text":"物理层：电缆等传输介质，传输高低电平信号。 网卡：工作在物理层和数据链路层。把来自介质的电信号（无线网卡是电波信号）转换成二进制0110…信号。然后通过给其添加标志位将其式封装成便于识别的单个数据帧。 接下来就是交给操作系统的内核部分去处理了。 内核会把这些数据帧解析根据约定好的格式转换成网络层ip报文或者icmp报文或者其他网络层的数据 ，然后再把这些网络层的报文转换成传输层的数据段，交付给相应的端口。 同时，操作系统为了编程人员方便，屏蔽了传输层的实现细节，向上预留了操作（读、写）传输层（TCP、UDP）数据的SOCKET接口。使得需要网络的应用程序可以直接通过socket编程收发数据。 TCP在三次握手的时候，发送的是tcp握手报文，握手成功后发送的是包裹着http消息的tcp报文。 三次握手，四次分手详解","tags":[{"name":"http、https","slug":"http、https","permalink":"http://yoursite.com/tags/http、https/"}]},{"title":"JS对象的等号赋值问题","date":"2019-01-16T03:39:01.000Z","path":"2019/01/16/JavaScript基础/JS对象的等号赋值问题/","text":"首先明确两点，不管是作为函数参数还是等号赋值：基本类型是值传递，引用类型是地址传递举个栗子：12345678910111213let obj1 = &#123; key1:1&#125;let obj2 = obj1;obj2 === obj1 // trueobj1 = null;console.log(obj1); // nullconsole.log(obj2); // &#123;key1:1&#125;obj1 = obj2;obj1.key1 = 2;console.log(obj2); // &#123;key1:2&#125; 区别：操作引用类型时，给变量重新赋值和修改变量所指向地址的内容，性质和效果都不一样！！！前者无副作用，后者有！！！","tags":[{"name":"JavaScript核心","slug":"JavaScript核心","permalink":"http://yoursite.com/tags/JavaScript核心/"}]},{"title":"JavaScript基础","date":"2019-01-16T03:39:01.000Z","path":"2019/01/16/JavaScript基础/JavaScript基础/","text":"javaScript JavaScript是一种专为与网页交互而设计的脚本语言，由下列三个不同的部分组成： ECMAScript，由 ECMA-262定义，提供核心语言功能； 文档对象模型（DOM），提供访问和操作网页内容的方法和接口； 浏览器对象模型（BOM），提供与浏览器交互的方法和接口。 1. ECMAScript ECMAScript就是对实现该标准规定的各个方面内容的语言的描述。 JavaScript实现了 ECMAScript， Adobe ActionScript同样也实现了 ECMAScript。ECMAS有很多种宿主，比如浏览器、NodeJS、AdobeFlash等 它规定了这 门语言的下列组成部分： 语法 类型 语句 关键字 保留字 操作符 对象 JS文件嵌入和外部加载的区别：可维护性、可缓存、适应未来 ECAMS语法：`区分大小写 标识符:就是指变量、函数、属性的名字，或者函数的参数; 第一个字符必须是：字母、下划线（_）或一个美元符号（$）； 关键字：1234567891011121314151617181920212223242526break do instanceof typeof case else new var catch finally return void continue for switch while debugger* function this with default if throw delete in try 变量定义：var message = ”666“; 1. 未经过初始化的变量，会保存一个特殊的值——undefined； 2. 用var定义的变量是局部变量。 3. 省略var定义的变量是全局变量。任何地方都可以引用。 4. 给多个变量同时赋值: var message = &quot;hi&quot;, found = false, age = 29; 数据类型： ECMAS定义了5种基本类型，String、Number、Boolean、Null、Undefined 1种复杂类型：Object，本质是由一组无序的key-value组成 常用引用类型： Array: 判断一个某个对象是不是数组最好使用：Array.isArray() 转换方法：数组调用toString时，会调用数组每一项的toString方法，然后拼接成逗号分隔的字符串。但是可以通过数组的join方法改变分隔符。 栈方法(后进先出)： push()：接收任意数量的参数，把他们逐个添加到数组末尾，并返回修改后数组的长度。 pop()：从数组末尾移除最后一项，减少length，并返回移除的项。 队列方法（先进先出）： push()：同栈。 shift()：移除数组中第一个项，并返回该项，同时将数组长度减1。 unshift()：与shift用途相反，能在数组的前端添加项，并返回新数组的长度。tips：同时使用unshift和pop方法可以从相反的方向来模拟队列。 重排序方法： reverse(): 逆置该数组 sort(): 默认按升序排列，为了实现排序，sort方法会调用每个数组项的toString方法，然后把得到的字符串按字典序进行排序。即使数组中的每一项都是数值，sort方法比较的也是字符串。如： 123456789var values = [0, 1, 5, 10, 15];values.sort();alert(values);//0,1,10,15,5// 因为“10”位于“5”的前面----------------------------var a = [&apos;1&apos;,&apos;2&apos;,&apos;5&apos;,&apos;10&apos;,&apos;15&apos;,&apos;21&apos;]a.sort()[&quot;1&quot;, &quot;10&quot;, &quot;15&quot;, &quot;2&quot;, &quot;21&quot;, &quot;5&quot;] 由以上可知，sort方法不靠谱，因此sort方法可以接受一个比较函数作为参数，以便我们指定那个值位于哪个值的前面。如： 123456789function compare(value1, value2) &#123; if (value1 &lt; value2) &#123; return -1; &#125; else if (value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0; &#125;&#125; 操作方法： concat():方法可以基于当前数组中的所有项创建一个新数组。具体来说，这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。无参情况下，它只是复制当前数组并返回副本。如果传递给concat()方法的是一或多个数组，则该方法会将这些数组中的每一项都添加到结果数组中。如果传递的值不是数组，这些值就会被简单地添加到结果数组的末尾。 slice()：在只有一个参数的情况下，slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项——但不包括结束位置的项。注意， slice()方法不会影响原始数组。 splice(): 删除：splice(起始位置，删除的项数) 插入：splice（起始位置，0（要删除的项数），要插入的项） 替换：splice（起始位置，要删除的项数，要插入的项数）； 注：splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项（如果没有删除任何项，则返回一个空数组） 位置方法 indexOf()：从前往后，第一个参数为查找目标，可选接受第二个参数指定起始位置 lastIndexOf()：从后往前 二者都返回要查找的目标的位置，如果查不到则返回-1 迭代方法 every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回 true。 filter()：对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组。 forEach()：对数组中的每一项运行给定函数。这个方法没有返回值。 map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。 some()：对数组中的每一项运行给定函数，如果该函数对任一项返回 true，则返回 true。 每个方法都接收两个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域对象——影响 this 的值。传入这些方法中的函数会接收三个参数：数组项的值、该项在数组中的位置和数组对象本身。 归并方法 reduce(): reduceRight() Array对象拥有length方法，且该length是可写的。 Object： 常用函数： valueOf() // 返回对象的字符串、数值或布尔值表示返回一个对象对应的基本类型字面量值,无法转换的直接返回对象本身。 toString() // hasOwnProperty(propertyName) // 不检查原型链 isPrototypeOf(object) // 检查传入的对象是否是传入对象的原型 Date： RegRex： Function： 每个函数都是Function类型的实例，而且都与其他引用类型一样具有属性和方法。由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定， 函数声明与函数表达式与Function构造函数： 解析器会率先读取函数声明，并将其提升执行环境顶部，使其在执行任何代码前可用； 函数表达式必须等到解析器执行到他所在的代码航才会真正的被执行。 var sum = new Function(“num1”,”num2”,”return num1 + num2”); 没有重载（重载是方法签名不同，即拥有不同的参数个数和类型，而JS中参数是以一个数组的形式接收的） 函数体内部可以使用的两个特殊对象：arguments和this arguments是一个类数组对象，包含着传入函数中的所有参数，访问方式为： 12第一个元素是 arguments[0]，第二个元素是argumetns[1]，以此类推使用 length 属性来确定传递进来多少个参数。 arguments还保存着一个名叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数： 1234567function factorial(num)&#123; if (num &lt;=1) &#123; return 1; &#125; else &#123; return num * arguments.callee(num-1) &#125;&#125; this：this 引用的是函数据以执行的环境对象—或者说是this的值，当在全局作用域中调用函数时，this对象引用的就是window。 执行环境：简称环境，它定义了变量或函数有权访问的其他数据，决定了他们各自的行为，每个环境都有一个与之关联的变量对象,环境中定义的所有变量和函数都保存在这个对象中，代码无法访问这个对象,但解析器在后台使用它解析数据。 全局执行环境是最外围的一个执行环境。在web浏览器中，它是window对象，因此所有全局变量和函数都是作为window对象的属性和方法创建的。 作用域链： 每个函数都有自己的执行环境，当执行进入一个函数时，函数的环境就会被推入一个环境栈中。 当代码在一个环境中执行时，会创建变量对象的一个作用域链。 作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，作用域链的前端始终都是当前执行代码所在的环境对象。 如果这个环境是函数，则将其活动对象作为环境对象,活动对象在最开始时只包含一个变量，即arguments对象（这个对象在全局环境中是不存在的）。 作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境，这样一直延续到全局的执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。 标识符解析就是沿着作用域链一级一级的搜索标识符的过程，搜索过程始终从作用域链的前端开始，逐级的向后回溯，直到找到为止。 关系整理： 执行环境和作用域是完全两个不同的概念 函数的每次调用都有与之相关的作用域和执行环境，从根本上说，作用域是基于函数的，执行环境是基于对象的。 作用域涉及到被调用函数的变量访问，并且同一个函数不同的调用场景下作用域都是不一样的。 执行环境始终是this关键字的值。他拥有当前所执行代码所属对象的引用。 每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。 作用域链把从子到父再到全局作用域的执行环境的变量对象串起来。 变量对象和this的关系： this始终指向调用函数的那个对象。 所谓变量提升就是把一个作用域里面的变量和函数的声明信息放进该作用域最顶上。 函数的属性和方法： 属性： prototype：对于ECMAScript 中的引用类型而言， prototype是保存它们所有实例方法的真正所在。换句话说，诸如toString()和valueOf()等方法实际上都保存在 prototype 名下，只不过是通过各自对象的实例访问罢了 length：函数希望接收的参数个数 方法：用于改变函数执行的作用域，即上下文环境。 call():一个是指定的作用域，后面的是逐个列举的参数。 apply():接受两个参数，第一个是指定的作用域，第二个是一个参数数组（或者是arguments对象）。 使用 call()（或apply()）来扩充作用域的最大好处，就是对象不需要与方法有任何耦合关系。 当需要借用某个对象的方法，该方法与其所属对象有较强耦合关系，即该方法需要操作this bind():会创建一个函数的实例，并且将它的this绑定到传递给bind的值。 函数的执行过程和作用域：（搞清楚: 变量对象、活动对象、作用域链） 每个执行环境都有一个表示变量的对象—-变量对象。 全局变量对象始终存在，局部环境的变量对象只在函数执行的过程中存在。 创建局部函数的时候，会创建一个预先包含全局变量对象的作用域链，这个作用域链被保存在内部的[[Scope]]属性中。4.当调用局部函数时，会为函数创建一个执行环境 然后通过复制函数的[[Scope]]属性中的对象，构建起执行环境的作用域链 此后，又有一个活动对象（在此作为变量对象使用）被创建并被推入执行环境作用域链的前端。 作用域链本质上是一个指向变量对象的指针列表，他只引用但不实际包含变量对象。 基本包装类型(String Number Boolean)： 实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。即：通过字面量创建的对象在调用属性和方法时会被对象包装器暂时包装成一个对象，具有对象的性质。 123(1) 创建一个对应包装类的一个实例;(2) 在实例上调用指定的方法 ;(3) 销毁这个实例。 基本包装类型和引用类型的区别： 12341. 引用类型与基本包装类型的主要区别就是对象的生存期。2. 使用 new 操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。3. 而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。4. 这意味着我们不能在运行时为基本类型值添加属性和方法 下面的例子： 123var s1 = &quot;some text&quot;;s1.color = &quot;red&quot;;alert(s1.color); //undefined 基本类型的包装类在使用typeof操作符时会像其它实例对象一样，返回object，使用instanceof可以得到正确的类型。 Object的构造方法就像一个工厂一样，根据传入的参数的类型返回对应的包装类实例。 Boolean类 var b = new Boolean(true/false); 同时重写了valueof方法，对Boolean的实例返回基本类型ture或false，也重写了toString方法，返回字符串true或false。 布尔表达式中的所有对象都会被转换为 true。 String类： 有个length属性，表示多少字符。 字符访问方法： charAt(index):输出指定位置的字符 等价于 “***”[index] charCodeAt(index):输出指定位置字符的编码 字符操作方法： concat():A.concat(B, …),返回拼接后的字符串 一般用‘+’代替了 slice： substring： substr： 1231. 以上三个方法都时基于已有字符串创建新的字符串2. slice和substring有两个参数：第一个是起始位置，第二个是指定的是子字符串**最后一个字符后面的位置**3. substr的第二个参数指返回的字符串个数。 trim(): 返回一个副本，删除原字符串前缀和后缀的所有空字符串- toLowerCase(),toUpperCase() 字符串的模式匹配方法 match(),本质上与RegExp的exec方法相同，match接受一个参数，要么是RegExp对象，要么是一个正则表达式。 返回的是一个数组。数组的第一项是与整个模式匹配的字符串，之后的每一项（如果有）保存着与正则表达式中的捕获组匹配的字符串。 1234[&quot;j&quot;, index: 2, input: &quot;2ajlkfljksafjk&quot;, groups: undefined]注意：有没有多个匹配看你这个则表达式的flag的设置: g（全局匹配）/i（忽略大小写）/m（多行）的组合 Number： 重写了toString和valueof方法 toFixed(n)方法会按照指定的小数位返回数值的字符串表示 单体内置对象： 内置对象的定义是： “由 ECMAScript实现提供的、不依赖于宿主环境的对象，这些对象在ECMAScript程序执行之前就已经存在了。”意思就是说，开发人员不必显式地实例化内置对象，因为它们已经实例化了. 除了Global和Math对象外，Number、String、Boolean、Array、Object、Date、Function、GMT类型的实例也是单体内置对象。他们的属性和方法可以直接使用。 Global Global和Math是纯粹的对象，没有构造函数，也无法实例化新的对象。所有在全局作用域里面声明的变量和方法都是Global对象的属性。 只有Global和Math可以直接使用Global. /Math.；其余的只能是在实例化的对象中调用属性和方法，即他们的属性和方法属于其构造函数。 Global的属性：Infinity、NaN、Undefined Global的方法： encodeURI(URIString)/decodeURI():把字符串（完整的urlString）作为URI进行编码/解码； 1231. 该方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码： - _ . ! ~ * &apos; ( ) 。2. 该方法的目的是对 URI 进行完整的编码，因此对以下在 URI 中具有特殊含义的 ASCII 标点符号，encodeURI() 函数是不会进行转义的：;/?:@&amp;=+$,#3. 提示：如果 URI 组件中含有分隔符，比如 ? 和 #，则应当使用 encodeURIComponent() 方法分别对各组件进行编码。 encodeURIComponent/decodeURIComponent:对（部分urlString）进行编码和解码； parseInt(string, radix): 解析一个字符串，并返回一个整数。radix是要解析数字的基数。 parseFloat(string): 解析一个字符串，返回一个浮点数 isFinite(number)：检测是否无穷大 isNaN(number):是否非数字 Number(oject) String(object) 面向对象的程序设计1.理解对象（配置属性的特性） ECMA定义内部采用的特性时，顺道描述了对象的属性的各种特征。 这些特性是内部值，JS中不能访问，规范把他们放在了两对括号中，如[[Enumerable]] 属性可以分为两类： 数据属性：有四个描述其行为的特征： [[configurable]]:默认值为true [[Enumerable]]:默认为true，表示能否使用for-in [[Writable]]:默认为true，表示能否修改属性 [[value]]:默认为undefined，用于记录属性的值 访问器属性： 2.创建对象 工厂模式 构造函数模式 原型模式 组合使用构造函数和原型模式 动态原型模式 寄生构造函数 稳妥构造函数 3.继承 构造函数、原型对象、实例的关系：（P163、P164 JavaSrcipt高级程序设计3） 每个构造函数都内置一个属性prototype，指向其原型对象。 每个实例都有一个[[Prototype]],指向其构造函数的原型对象。 原型对象有一个属性constructor，指向该原型对象的构造函数。 可以通过给构造函数的原型对象赋值（用父类的实例），即重写子类的原型对象，这样子类就拥有了父类所有的属性和方法（通过父类实例获得,这样将导致子类的原型对象中没有constructor属性，不过可以手动添加。），同时，借助父类实例中的[[Prototype]],子类可以向上找到父类的原型对象。 闭包、匿名函数、块级作用域、立即执行函数 闭包和匿名函数：匿名函数就是没有名字的函数（函数表达式、作为对象的value部分），闭包就是可以访问一个函数作用域里变量的函数（名字可有可无）。 由于JS只有函数作用域和全局作用域，因此声明在一些执行块中的变量（如for循环）只有在其所属函数体执行完毕才会释放，这可能会对函数内的变量造成一定干扰。 为了解决这个问题，可以将需要排除干扰的部分用一个新的function包围起来，这样被包裹的部分就就形成了一个新的函数作用域。 但是一个新的function并不会自己执行，即存放在里面的代码不能得到执行，因此有了立即执行函数。既保留了函数作用域，又得到了执行。 这样形成的函数具有访问其所处执行环境（函数）里面的变量的能力，故被称为闭包。 由于闭包会携带包含它的函数的作用域，因此也就具备了持久访问包含它的函数的作用域（变量对象）的能力。P180图 由于闭包保存的有包含其的函数的变量对象，并且，当调用闭包时，包含它的函数已经返回，因此变量对象的值也已经确定下来，即为最终返回时的状态。 每个函数都有一个作用域链，最前面(index为0)存放的是当前活动对象,接着是父级函数的变量对象。 function里面再声明一个function（函数声明式）,在函数体外无法访问第一个（父）function的作用域，因此声明在里面的函数（第二个function）无法在外部调用，并且也不会自己执行，对外部而言没有任何意义，不过可以在内部使用。 function里面嵌入函数表达式，类似与在函数内部声明变量，同样在外面无法访问， 2. DOM3. BOM window对象具有双重角色，既是通过JavaScript访问浏览器窗口的一个接口，又是ECMAScrip规定的Global对象。 所有在全局作用域中声明的变量和函数都会成为window对象的属性和方法。 窗口关系及框架： 如果页面包含框架，则每个框架都有自己的window对象，并且保存在frames集合中。 top对象始终指向最高层的框架，也就是说浏览器窗口 parent对象始终指向当前框架的直接上层框架 self对象指向window 窗口位置： window.screenLeft window.screenTop （除了firefox） window.screenX window.screenY 窗口大小： innerWidth innerHeight outerWidth outerHeight 文档区域： document.documentElement.clientWidth和document.documentElement.clientHeight指浏览器当前窗口的视图区域，不包括工具栏滚动条等的实际宽高。 document.documentElement.scrollWidth和document.documentElement.scrollHeight指浏览器body页面的大小，即网页整体大小。 document.body.scrollTop和document.body.scrollLeft是指整个网页的上方或者左边被卷起来的部分。(for:IE9及更早版本)；其他情况可以使用window.pageXOffset和window.pageYOffset代替。 可以通过document.ducumentElement.scrollHeight - document.body.scrollHeight得到 窗口区域： window.screen.width和window.screen.height指整个显示器屏幕大小的宽高 window.screenTop和window.screenLeft是浏览器窗口顶部/左端距离屏幕边缘的部分 window.innerHeight和window.innerWidth是指当前窗口的可视区域，包括滚动条的宽高，不包括工具栏（注意与document.documentElement.clientWidth/Height的区别）","tags":[{"name":"JavaScript核心","slug":"JavaScript核心","permalink":"http://yoursite.com/tags/JavaScript核心/"}]},{"title":"JavaScript深拷贝、浅拷贝","date":"2019-01-16T03:39:01.000Z","path":"2019/01/16/JavaScript基础/JavaScript深拷贝、浅拷贝/","text":"参考：详解javaScript的深拷贝 浅拷贝核心： 仅仅是值拷贝12var a = [1,2,3];var b = a; // 仅仅是把变量a的内存地址赋给了b，二者指向内存同一块区域 深拷贝 一层拷贝，适用于单层的js对象或者数组，且值为基本类型变量（如number,String,boolean）。 直接遍历 123456789101112131415161718192021function singleCopy(obj)&#123; if(typeof obj !== &apos;object&apos;)&#123; throw new Error(&apos;arguments is valid!&apos;); &#125; if(obj.__proto__.constructor === Array)&#123; var newObj = []; for(var item of obj)&#123; newObj.push(item); &#125; &#125; else &#123; var newObj = &#123;&#125;; for(var item in obj)&#123; if(obj.hasOwnProperty(item))&#123; newObj[item] = obj[item]; &#125; &#125; &#125; return newObj; &#125; - 对于数组： &gt; var newArray = [].slice.call(array_source); &gt; var newArray = [].concat.call(array_source); - 对于对象： &gt; var newObj = Object.assign({}, obj); 深层拷贝 借用JSON对象的方法，简单粗暴，适用除特殊类型（正则，函数）之外的大多数场景。 var obj_target = JSON.parse(JSON.stringify(obj_resource)) 使用递归,可以增加想要适配特殊类型的代码。 123456789101112function deepCopy(obj)&#123; if(typeof obj !== &apos;object&apos;)&#123; throw new Error(&apos;params is valid&apos;); &#125; var newObj = obj.constructor === Array?[]:&#123;&#125;; for(var item in obj)&#123; newObj[item] = typeof obj[item] === &apos;object&apos; ? deepCopy(obj[item]):obj[item]; &#125; return newObj;&#125;","tags":[{"name":"JavaScript核心","slug":"JavaScript核心","permalink":"http://yoursite.com/tags/JavaScript核心/"}]},{"title":"JavaScript精粹选摘","date":"2019-01-16T03:39:01.000Z","path":"2019/01/16/JavaScript基础/JavaScript精粹选摘/","text":"语句 每个&lt;script>标签都提供一个被编译且立即执行的编译单元。因为缺少链接器，JavaScript把他们一起抛入一个公共的全局名字空间中。 假值，在判断真假的句子中返回false NaN null undefined ‘’ 0 null 运算符优先级 属性存取及函数调用 . [] () 一元运算符 （注意跟加减的区别） delete new typeof + - ！ 乘法、除法、取模 * / % 加（连接）、减 + - 不等式运算符 ‘&gt;=’, ‘&lt;=’,’&gt;’,’&lt;’ 等式运算符（注意高出逻辑运算符优先级） === !== 逻辑与 &amp;&amp; 逻辑或 || 三元运算符 ?: 函数字面量 函数字面量定义了函数值，有一个可选的名字，用于递归的调用自己。 对象 基本性质 JavaScript简单类型包括数字、字符、布尔值、null、undefined，其他的所有值都是对象。 数组、函数、正则表达式都是对象。 对象是属性的容器，属性名可以是包含空字符串在内的任意字符串,属性值可以是除了undefined之外的任何值。 通过原型链，允许对象继承另一对象的属性。使用它能减少对象初始化时间和内存消耗。 对象字面量 key可用引号也可以不用，但当key的string含有不合法字符串时，必须用引号 对象的检索 当key不是保留字的时候可以使用obj[keyString]也可以用obj.key访问对应值。 对象的原型 每个对象都由隐藏属性__proto__链接到一个原型对象，并且可以从中继承属性。 所有通过对象字面量创建的对象的__proto__都指向Object.prototype对象。 原型对象只在检索时有用，在更新对象时不受影响，除非显式修改原型对象：obj.__proto__ = balabala 或 obj.prototype = balabala 反射 通过反射检查数据的类型，可以通过typeof、hasOwnProperty()等方法。 枚举 对于对象，可以使用for…in枚举，会把包括原型里面的属性都遍历。例如： 12345for(key in obj)&#123; if(typeof obj.key === &apos;object&apos;)&#123; &#125;&#125; - 注意：for(item of items)中，item是值。 删除 可以通过delete关键字删除某个key-value,比如：delete obj.name 或者 delete.__proto__.name 减小全局变量污染 只创建一个全局变量（对象），其他所有代码都写在这个对象里面 使用闭包（推荐） 函数 函数对象 函数也是一个对象，且其proto属性连接到Function.prototype，而Function.prototype的proto指向Object.prototype; 每个函数对象在创建时随带一个prototype属性指向其原型对象。默认情况下，prototype对象里面只有一个constructor属性，指向构造函数（该函数对象）。 每个函数在创建时，会有两个附加属性：函数上下文、实现函数行为的代码 函数字面量：function 可选名字(可选形参){可选语句} 函数调用方式：见this相关问题 函数参数: 可以定义一个无参函数，但是在调用时传递一些参数，然后在函数体内通过arguments对象获取 函数返回: 一个函数总会返回一个值，如果没有指定则返回undefined 如果函数在前面加new调用，且返回值不是一个对象，则返回该this 函数执行异常 可以随时在语句中使用throw关键字，后面跟一个自定义的Exception，这个Exception可以是一个简单值，也可以是一个自定义对象。 throw语句用来抛出一个用户自定义的异常。当前函数的执行将被停止（throw之后的语句将不会执行），并且控制将被传递到调用堆栈中的第一个catch块。不管throw后面抛出的是啥，一旦执行，且调用者函数中没有catch块，程序将会报错且终止。 可以通过继承异常基类Error自定义异常类型,可以添加除了Error.prototype.message和Error.prototype.name之外的属性和方法。 模块 我们可以通过使用函数和闭包实现模块，模块是一个提供接口却隐藏状态与是实现的函数或对象。 模块的一般形式为：一个定义了私有变量和函数的函数，利用闭包创建可以访问私有变量和函数的特权方法，最后返回这个特权函数或者把他们保存到一个可以访问到的地方(比如挂在global对象上)。 级联 不带有return语句的函数默认返回undefined 对于修改某个对象的状态这样的函数，可以使其返回this而不是undefined，就可以启用级联。也即是链式调用。 套用 函数也是值，从而可以像使用值的方式去操纵函数。 套用允许我们将函数与传递给它的参数相结合产生一个新的函数。 记忆 利用闭包特性，将函数的历史执行结果以（参数：函数返回值）的形式用数组或对象保存在函数内部，下次再输入某个参数时，首先判断该参数是否已经被计算过，如果是则直接返回保存的结果。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647function wrapper()&#123; var result = []; return function(i)&#123; var temp = result[i]; if(!temp)&#123; // 正常执行计算 result[i] = 计算结果; return 计算结果; &#125; return temp； &#125;&#125;// 继续抽象，使缓存可以自定义，执行函数体也可以自定义(不支持递归)function compute(store, func)&#123; return function(i)&#123; if (typeof store[i] !== '某类型')&#123; store[i] = func(i); return store[i]; &#125; return store[i]; &#125;&#125;===============================================================// 如果要考虑递归的情况，做如下修改：function comupute(store, func)&#123; var comp = function(i)&#123; if (typeof store[i] !== '某类型')&#123; store[i] = func(comp, i); return store[i]; &#125; return store[i]; &#125;; return comp;&#125;// 求和时的func可以这么定义var store = [0,1];var func = function(fun1, n)&#123; return fun1(n-1) + fun1(n-2);&#125;// 求阶乘可以这么定义var store = [1,1];var func = functin(fun1, n)&#123; return n*fun1(n-1);&#125; 继承JavaScript是一门弱类型语言，从不需要类型转换，对象的起源是无关紧要的，重要的是这个对象能做什么。在基于类的语言中，对象是类的实例，并且类可以从另一个类继承。JavaScript是一门基于原型的语言，这意味着对象直接从其他（原型）对象继承。 伪类 JavaScript的某些像类的语法隐蔽了他的原型机制。他不让对象直接直接从其他对象继承，反而插入了一个中间层，从而使构造器函数产生对象。参考：new操作符 12345678910PS：不管是不是显式继承，只要是new产生对象，内部都使用了原型机制。当代码 new Foo(...) 执行时，会发生以下事情：1、一个继承自 Foo.prototype 的新对象被创建。 &gt; var that = Object.creat(Foo.prototype); // 到这里的时候，其实已经完成了一个对象继承另一个对象。2、使用指定的参数调用构造函数 Foo ，并将 this 绑定到新创建的对象。new Foo 等同于 new Foo()，也就是没有指定参数列表，Foo 不带任何参数调用的情况。 &gt; var other = Foo.call(that, arguments); // 构造函数的返回值3、由构造函数返回的对象就是 new 表达式的结果。如果构造函数没有显式返回一个对象，则使用步骤1创建的对象。（一般情况下，构造函数不返回值，但是用户可以选择主动返回对象，来覆盖正常的对象创建步骤）。 &gt; return (typeof other === 'object' &amp;&amp; other) || that; 1234当一个函数对象被创建时，Function构造器产生的函数对象会运行类似这样的一些代码： &gt; this.prototype = &#123;constructer: this&#125;; // 新函数对象被赋予一个prototype属性，其值是包含一个constructor属性且属性值为该新函数对象。 对象说明符 很多时候，构造器要接受一大堆参数，因此在编写构造器时使其接受一个简单的对象说明符可能会更加友好。那个对象包含了将要构建的对象规格说明。 1234567比如：var Foo = function(a,b,c,d)&#123;&#125; 可以更改为：var Foo = function(&#123; param1: a, param2: b, param3: c, param4: d&#125;)&#123;&#125; 如果构造器会聪明的使用默认值，则传入的一些参数可以忽略掉。 数组数组是一段线性分配的内存，他通过计算偏移访问其中的元素。JavaScript并没有提供数组这种数据结构，而是提供了一种拥有一些类数组特性的对象。 它把数组的下标转变成字符串，用其作为属性。他明显比真正的数组慢，但它可以方便的使用。属性的检索和更新方式与对象一模一样，除了有一个可以用整数作为属性名的特性外。数组有他们自己的字面量格式，数组也有一套非常有用的内置方法。 关于数组长度： 每个数组都有一个length属性，并且length是没有上界的，当你用一个大于或等于length的数字作为下标来保存一个元素，那么length将增大来容纳新元素，不会发生数组越界。 length属性的值是这个数组的最大整数属性名加上1，她不一定等于数组里面的属性的个数。 []运算符会将他的表达式转换成一个字符串，如果该表达式有toString方法，就使用该方法的值。这个字符串将被用作属性名。如果则个字符串看起来像一个大于等于这个数组当前的length且小于4294967295的正整数，那么这个数组的length就会被重新设置为新的下标加1。 可以直接设置length的值，设置更大的length无须给数组分配更多的空间。更小的length会将下标大于等于新length的属性删除。可以通过把下标指定为一个数组当前的length来附加一个新元素到该数组尾部。push方法也可以。 删除数组元素 由于JavaScript数组其实就是对象，所以可以使用delete运算符从数组中移除元素：delete nums[2]; 然而，delete运算符会在数组中遗留一个空洞，被删除的属性和值都消失不见，但length不变。因为排在他后面的元素保留了他们最初的下标。 123a = [1,2,3,4];delete a[1];console.log(a); // [1,empty,3,4] 为了解决以上问题，可以使用数组的splice方法，他可以删除某些元素并将他们替换成其他的元素，第一个参数是起始位置下标，第二个参数是要删除的元素个数，删除位后面的元素会被删除并且以一个新的键值重新插入，大型数组效率低；当slice的参数为空时，默认返回一个长度和原数组相同的新数组。 数组的枚举 因为数组其实就是对象，所以for in语句可以用来遍历一个数组的所有属性。不幸的是，for in无法保证无序，并且还有可能意外得到原型链中的属性。 解决方案： 使用传统的for循环: for(var i = 0; i &lt; arr.length; i++){ console.log(arr[i]); } for…of语句在迭代对象（包括Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句。这种方法只会迭代迭代器中产生的数据。 使用数组还是对象 当属姓名是小而连续的整数时，使用数组，否则使用对象。 使用typeof array会返回’object’,并不能判断出类型，因此使用： typeof arr === ‘object’ &amp;&amp; arr.constructor === Array 数组的方法 Javascript提供了一套用于数组的方法，这些方法是被存储在Array.prototype中的函数。 多维数组 JavaScript没有多维数组，但它支持元素为数组的数组 1234567891011Array.prototype.matrix = function(m, n, initial)&#123; var a, i, j, mat = []; for(i=0;i&lt;m;i++)&#123; a = []; for(j=0;j&lt;n;j++)&#123; a[j] = initial; &#125; matrix[i] = a; &#125; return matrix;&#125; 正则表达式（对象）JavaScript同样对正则表达式有很好的支持，RegExp是JavaScript中的内置类，通过使用RegExp，用户可以自己定义模式来对字符串进行匹配。 JavaScript中的String对象的replace方法也支持使用正则表达式对串进行匹配。 元字符与特殊字符 1234567元字符 含义^ 串的开始$ 串的结束* 零到多次匹配+ 一到多次匹配? 零或一次匹配\\b 单词边界 范围及重复 123456789101112131415161718192021范围： 标志符 含义 […] 在集合中的任一个字符 [^…] 不在集合中的任一个字符 . 除\\n 之外的任一个字符 \\w 所有的单字，包括字母，数字及下划线 \\W 不包括所有的单字， \\w 的补集 \\s 所有的空白字符，包括空格，制表符 \\S 所有的非空白字符 \\d 所有的数字 \\D 所有的非数字 \\b 退格字符重复： 标记 含义 * 0次或多次 + 1次或多次 ? 0次或1次 &#123;n&#125; 重复 n 次 &#123;n,&#125; 重复 n 或更多次 &#123;n,m&#125; 重复至少 n 次，至多 m 次 分组与引用 括号的3个作用： 将子表达式表记起来，以区别于其他表达式 括号用来分组，当正则表达式执行完成之后，与之匹配的文本将会按照规则填入各个分组。 引用分组内容。即在同一个表达式中，后边的式子可以引用前边匹配的文本。 12345678910111213141516var str = \"hello, world\";var str = 'fair enough';均为合法字符，我们可能会设计出这样的表达式来匹配该声明：var pattern = /['\"][^'\"]*['\"]/;看来没有什么问题，但是如果用户输入：var str = 'hello, world\";var str = \"hello, world';我们的正则表达式还是可以匹配，注意这两个字符串两侧的引号不匹配！ 我们需要的是，前边是单引号，则后边同样是单引号，反之亦然。 因此，我们需要知道前边匹配的到底是“单”还是“双”。这里就需要用到引用， JavaScript 中的引用使用斜杠加数字来表示，如\\1 表示第一个分组(括号中的规则匹配的文本)， \\2 表示第二个分组，以此类推。 因此我们就设计出了这样的表达式：var pattern = /(['\"])[^'\"]*\\1/;在我们新设计的这个语言中，为了某种原因，在单引号中我们不允许出现双引号，同样，在双引号中也不允许出现单引号，我们可以稍作修改即可完成：var pattern = /(['\"])[^\\1]*\\1/; 使用正则表达式 创建正则表达式 使用字面量： var regex = /pattern/[switchs]; 使用RegExp对象： var regex = new RegExp(“pattern”, switchs) switchs有以下三种（可以组合使用）： 123456789修饰符 描述i 忽略大小写开关g 全局搜索开关m 多行搜索开关(重定义^与$的意义)eg: var pattern = /^javascript/; print(pattern.test(\"java\\njavascript\"));//false pattern = /^javascript/m; print(pattern.test(\"java\\njavascript\"));//true RegExp对象的方法： 1234方法名 描述test() 测试串中是否有合乎模式的匹配，不关心匹配结果，返回booleanexec() 对串进行匹配，返回需要分组的信息。compile() 编译正则表达式，用来改变表达式的模式，这个过程与重新声明一个正则表达式对象的作用相同 String对象中也有多个方法支持正则表达式操作： 12345方法 作用match(pattern) 匹配正则表达式，返回匹配数组replace(pattern, newStr) 替换split(pattern) 分割,返回一个数组search(pattern) 查找，返回首次发现的位置 方法JavaScript包含了少量用在标准类型上面的标准方法。 Array arr.concat(item): 返回一个新数组。它包含arr的浅复制（值拷贝），并将一个或多个item附加在其后，如果item是数组，则对每个元素使用arr.push(item)方法。 arr.join(separator)： 把一个array构造成一个字符串。首先将每个元素构造成一个字符串，并用一个separator为分隔符把他们连接在一起。默认的分隔符是’,’。为了实现无分隔符的连接，可以使用空字符串作为separator。 把大量的需要连接的字符串放到一个数组中，然后使用join方法通常比使用’+’号快。 arr.pop / arr.push : 数组像堆栈一样工作 arr.shift / arr.push : 数组像队列一样工作 arr.unshift : 从头部插入数据 arr.reverse : 逆置数组元素，返回当前工作数组 arr.slice(start, end) : 浅复制从start(arr[start])到end(不包括arr[end])的元素于一个新的数组中返回。 arr.splice(start, deleteCount, item…) : 从arr中移除一个或多个元素，并用新的item替换他们,返回一个包含被移除元素的数组。 arr.sort(compareFunction): JavaScript默认的比较函数会将数组元素转换成字符转后按字典序比较。 自定义比较函数，接收两个参数，如果这两个参数相等则返回0，如果第一个应该排在前面则返回一个负数，如果第二个应该排在前面则返回一个整数。 Number number.toFixed(fractionDigits) 把number转换成一个十进制数形式的字符串，可选参数fraction控制小数点后的数字位数，他的值必须在0-20之间，默认为0。 number.toPercision(precision) 把number转换成一个十进制数形式的字符串，可选参数precision控制有效数组的位数，他的值必须在0-21之间。 number.toString(redix) 把number转换成一个以radix进制形式的字符串，radix必须在2-36之间。 Object obj.hasOwnProperty(name): 判断对象自身是否包含name属性，不会查找原型链。 String str.charAt(position): 返回position处的字符(串，因为JavaScript并没有character类型)。不合法的position返回空字符串。 str.concat(str…): 连接字符串，很少使用，并没有’+’方便。 str.indexOf(searchStr, position): 从可选的指定位置查找字符串，返回第一个匹配字符的位置，否则返回-1。 str.lastIndexOf(searchStr, position): 倒着找 str.match str.replace str.search(pattern): 同indexOf，忽略g参数 str.slice(start, end): 浅复制 str.split(separator, llimit): 把str分割成字符数组，limit为数组的长度。 str.subString: 同slice，只是不能处理负参数，使用slice替换它","tags":[{"name":"JavaScript核心","slug":"JavaScript核心","permalink":"http://yoursite.com/tags/JavaScript核心/"}]},{"title":"addEventListener和removeEventListener的添加和移除","date":"2019-01-16T03:39:01.000Z","path":"2019/01/16/JavaScript基础/addEventListener和removeEventListener的添加和移除/","text":"tips 回调接受一个参数：一个基于Event 的对象，描述已发生的事件，并且它不返回任何内容。 第三个参数是一个布尔值表示是否在捕获阶段调用事件处理程序, 在父子都添加了事件监听的时候，可以决定谁先触发。 如果要移除事件句柄，addEventListener() 的执行函数必须使用外部函数，使用匿名函数无法移除 addEventListener中的第三个参 数是useCapture, 一个bool类型。当为false时为冒泡获取(由里向外)，true为capture方式(由外向里)。123&lt;div id=&quot;id1&quot; style=&quot;width:200px; height:200px; position:absolute; top:100px; left:100px; background-color:blue; z-index:4&quot;&gt; &lt;div id=&quot;id2&quot; style=&quot;width:200px; height:200px; position:absolute; top:20px; left:70px; background-color:green; z-index:1&quot;&gt;&lt;/div&gt; &lt;/div&gt; eg1： 123document.getElementById(&apos;id1&apos;).addEventListener(&apos;click&apos;, function() &#123; console.log(&apos;id1&apos;);&#125;, false); document.getElementById(&apos;id2&apos;).addEventListener(&apos;click&apos;, function() &#123; console.log(&apos;id2&apos;);&#125;, false); 点击id2的div结果是: id2， id1123document.getElementById(&apos;id1&apos;).addEventListener(&apos;click&apos;, function() &#123; console.log(&apos;id1&apos;);&#125;, false); document.getElementById(&apos;id2&apos;).addEventListener(&apos;click&apos;, function() &#123; console.log(&apos;id2&apos;);&#125;, true); 结果是: id2, id1123document.getElementById(&apos;id1&apos;).addEventListener(&apos;click&apos;, function() &#123; console.log(&apos;id1&apos;);&#125;, true); document.getElementById(&apos;id2&apos;).addEventListener(&apos;click&apos;, function() &#123; console.log(&apos;id2&apos;);&#125;, false); 结果是：id1，id2123document.getElementById(&apos;id1&apos;).addEventListener(&apos;click&apos;, function() &#123; console.log(&apos;id1&apos;);&#125;, true); document.getElementById(&apos;id2&apos;).addEventListener(&apos;click&apos;, function() &#123; console.log(&apos;id2&apos;);&#125;, true); 结果是：id1，id2 测试一1234567891011var Test = function() &#123; this.element = document.body; this.handler = function() &#123; console.log(this); &#125;; this.element.addEventListener(&apos;click&apos;, this.handler.bind(this), false); this.destroy = function() &#123; this.element.removeEventListener(&apos;click&apos;, this.handler, false); &#125;;&#125;;var test = new Test(); 但是，测试结果发现，调用 test.destroy() 后，点击依旧有效。明明按照以前看的文档说的，add 和 remove 的时候是同一个函数啊。 测试二于是，又调整了一下代码。12345678910var Test = function() &#123; this.element = document.body; this.handler = function() &#123; console.log(this); &#125;; this.element.addEventListener(&apos;click&apos;, this.handler, false); this.destroy = function() &#123; this.element.removeEventListener(&apos;click&apos;, this.handler, false); &#125;;&#125;; 去掉了 add 时的 bind，再测试发现点击不响应了。 结论经过测试，add 和 remove 事件监听回调时，既不能使用匿名函数，也不能改变指定函数的上下文，因为bind函数其实会返回一个新的函数。","tags":[{"name":"JavaScript核心","slug":"JavaScript核心","permalink":"http://yoursite.com/tags/JavaScript核心/"}]},{"title":"Object构造函数的常用方法","date":"2019-01-16T03:39:01.000Z","path":"2019/01/16/JavaScript基础/Object构造函数的常用方法/","text":"Object.creat() 返回一个包含指定原型对象的对象 Object.create(proto, [propertiesObject]); 首要功能：创建一个新对象 可选功能：为创建的新对象指定一个原型对象，内部原理其实是改变新对象的proto指向。 可选功能：为创建的新对象添加一些新的属性 传统的通过原型链继承，或者组合继承方法，都是把一个父类的实例赋给子类的原型对象,由于父类的实例的proto指向父类的原型对象，这样的话子类的原型上就有了父类实例的所有属性和父类的原型对象。 Object.assign() 合并对象 Object.assign(target, …sources) // ES6 MDN解释：用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。 注：只要不设置 首要功能：Object.assign是ES6新添加的接口，主要的用途是用来合并多个JavaScript的对象。 关于Object.assign的深拷贝问题：","tags":[{"name":"JavaScript核心","slug":"JavaScript核心","permalink":"http://yoursite.com/tags/JavaScript核心/"}]},{"title":"cookie相关","date":"2019-01-16T03:39:01.000Z","path":"2019/01/16/JavaScript基础/cookie相关/","text":"介绍：Cookie是由HTTP服务器设置的，保存在浏览器中的文件，用于弥补http协议无状态的不足。 分类： 会话cookie：不设置它的生命周期expires时的状态，浏览器的开关就是一次会话。 持久cookie：在过期前都有效，且cookie会自动将数据传送到服务器端。 格式cookie是一个以等号分割key和value，不同cookie用分号加空格（; ）分开的字符串。 常见用法： cookie的几种常见属性：document.cookie=”key=value;expires=失效时间;path=路径;domain=域名;secure;(secure表安全级别） 比如： YNOTE_LOGIN=3||1533575276767; YNOTE_CSTK=UMerv24j; 使用： 读取所有可从此位置访问的Cookie：allcookie = document.cookie 设置一个（新）cookie：document.cookie = ***，此方法一次只能对一个cookie进行设置或更新 实例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// key : cookie 名// value : cookie 值// options : 可选配置参数// options = &#123;// expires : 7|new Date(), // 失效时间// path : &quot;/&quot;, // 路径// domain : &quot;&quot;, // 域名// secure : true // 安全连接// &#125;function cookie(key, value, options) &#123; /* read 读取 */ // 如果没有传递 value ，则表示根据 key 读取 cookie 值 if (typeof value === &quot;undefined&quot;) &#123; // 读取 // 获取当前域下所有的 cookie，保存到 cookies 数组中 var cookies = document.cookie.split(&quot;; &quot;); // 遍历 cookies 数组中的每个元素 for (var i = 0, len = cookies.length; i &lt; len; i++) &#123; // cookies[i] : 当前遍历到的元素，代表的是 &quot;key=value&quot; 意思的字符串， // 将字符串以 = 号分割返回的数组中第一个元素表示 key， // 第二个元素表示 value var cookie = cookies[i].split(&quot;=&quot;); // 判断是否是要查找的 key，对查找的 key 、value 都要做解码操作 if (decodeURIComponent(cookie[0]) === key) &#123; return decodeURIComponent(cookie[1]); &#125; &#125; // 没有查找到指定的 key 对应的 value 值，则返回 null return null; &#125; /* 存入 设置 */ // 设置 options 默认为空对象 options = options || &#123;&#125;; // key = value，对象 key，value 编码 var cookie = encodeURIComponent(key) + &quot;=&quot; + encodeURIComponent(value); // 失效时间 if ((typeof options.expires) !== &quot;undefined&quot;) &#123; // 有配置失效时间 if (typeof options.expires === &quot;number&quot;) &#123; // 失效时间为数字 var days = options.expires, t = options.expires = new Date(); t.setDate(t.getDate() + days); &#125; cookie += &quot;;expires=&quot; + options.expires.toUTCString(); &#125; // 路径 if (typeof options.path !== &quot;undefined&quot;) cookie += &quot;;path=&quot; + options.path; // 域名 if (typeof options.domain !== &quot;undefined&quot;) cookie += &quot;;domain=&quot; + options.domain; // 安全连接 if (options.secure) cookie += &quot;;secure&quot;; // 保存 document.cookie = cookie;&#125; // 从所有的 cookie 中删除指定的 cookiefunction removeCookie(key, options) &#123; options = options || &#123;&#125;; options.expires = -1; // 将失效时间设置为 1 天前 cookie(key, &quot;&quot;, options);&#125;","tags":[{"name":"JavaScript核心","slug":"JavaScript核心","permalink":"http://yoursite.com/tags/JavaScript核心/"}]},{"title":"javascript如何控制多个异步事件同时返回","date":"2019-01-16T03:39:01.000Z","path":"2019/01/16/JavaScript基础/javascript如何控制多个异步事件同时返回/","text":"一、Promise.all()方法二、手动控制1234567891011121314151617181920212223242526let countFunc = (function timerCount(count)&#123; let asycArr = []; return function(data)&#123; asycArr.push(data); if(asycArr.length === count)&#123; console.log(asycArr); return asycArr; &#125; &#125;&#125;)(3);let promise1 = new Promise((resolve,reject)=&gt;&#123; resolve(1);&#125;).then(data=&gt;&#123; countFunc(data);&#125;);let promise2 = new Promise((resolve,reject)=&gt;&#123; resolve(2);&#125;).then(data=&gt;&#123; countFunc(data);&#125;);let promise3 = new Promise((resolve,reject)=&gt;&#123; resolve(3);&#125;).then(data=&gt;&#123; countFunc(data);&#125;);","tags":[{"name":"JavaScript核心","slug":"JavaScript核心","permalink":"http://yoursite.com/tags/JavaScript核心/"}]},{"title":"reduce","date":"2019-01-16T03:39:01.000Z","path":"2019/01/16/JavaScript基础/reduce/","text":"reduce为ES6中新增的方法，接受两个参数，回调函数和初始值。回调函数接受4个参数，除了与map、forEach等相同的后三个参数外，还多了第一个累计值参数初始值会在第一次调用回调函数时作为第一个参数传入以后每次循环的累计值，是根据上次回调函数return的结果定义的，如果在回调函数体中不改变或者不return，累计值不会改变。最终reduce函数返回的是一个值","tags":[{"name":"JavaScript基础","slug":"JavaScript基础","permalink":"http://yoursite.com/tags/JavaScript基础/"}]},{"title":"null、undefined、NaN","date":"2019-01-16T03:39:01.000Z","path":"2019/01/16/JavaScript基础/null、undefined、NaN/","text":"Undefined类型 Undefined类型就只有一个值，即特殊的undefined。在使用var声明变量但未对其加以初始化时，这个变量的值就是undefined。 一般不需要显示的将一个变量设置为undefined值的情况，字面值undefined的主要目的是用于比较，区分空对象指针与未经初始化的变量。 对于未经声明的变量，使用时会报错，reference Error。 声明但未初始化和未声明的变量，使用typeof操作符都会返回undefined。 Null类型 Null类型是第二个只有一个值的数据属性，这个特殊值是null。 null值表示一个空对象指针，而这也正是使用typeof操作符检测null值时会返回”object”的原因。 如果定义的变量要在将来用于保存对象，那么最好将她初始化为null而不是其他值。这样一来，只要直接检查null值就可以知道相应的变量是否已经保存了一个对象的引用。 实际上，undefined值是派生自null值的,因此null==undefined返回true。 NaN Not a Number，为Number类型的一个属性，代表非数字值的特殊值。 1语法：Number.NaN ECMAScript能表示的数值区间为：[Number.MIN_VALUE, Number.MAX_VALUE],超过之后就用一个特殊的Infinity表示。 任何涉及NaN的操作(运算)都会返回NaN NaN与任何值都不相等，包括它自己 判断一个变量是不是number，用window.isNaN()函数 123456789101112isNaN(1); // false isNaN(&apos;1&apos;); // falseisNaN(&quot;1&quot;); // falseisNaN(&apos;-0.2&apos;); // falseisNaN(&apos;-0.2a&apos;); // trueisNaN(&quot;a&quot;); // trueisNaN(false); // falseisNaN(true); // falseisNaN(null); // falseisNaN(undefined); // trueisNaN(new Array(1,2)); // true isNaN()在接收到一个值之后，会尝试将这个值转换为数值。某些不是数值的值会直接转换为数值，例如字符串”10”或 Boolean 值。而任何不能被转换为数值的值都会导致这个函数返回true。 isNaN()也可以接受一个对象作为参数，它会首先调用对象的valueOf方法，然后确定该方法返回的值是否可以转换为数值，如果不能，则基于这个返回值再调用toString方法，再测试返回值。 null和undefined异同 二者都是5种基本类型之一，但并不像其他三种(String、Number、Boolean)拥有构造函数，因此不是构造器类型，无法使用new，也无法拥有任何属性和方法。 null是关键字；undefined是Global对象的一个属性 null是对象(空对象, 没有任何属性和方法)；undefined是Undefined类型的值。试试下面的代码： 12document.writeln(typeof null); //return object document.writeln(typeof undefined); //return undefined 对象模型中，所有的对象都是Object或其子类的实例，但null对象例外： 1document.writeln(null instanceof Object); //return false null等值(\\==)于undefined，但不全等值(===)于undefined： 12document.writeln(null == undefined); //return true document.writeln(null === undefined); //return false 运算时null与undefined都可以被类型转换为false，但不等值于false： 123document.writeln(!null, !undefined); //return true,true document.writeln(null==false); //return false document.writeln(undefined==false); //return false","tags":[{"name":"JavaScript核心","slug":"JavaScript核心","permalink":"http://yoursite.com/tags/JavaScript核心/"}]},{"title":"函数专题","date":"2019-01-16T03:39:01.000Z","path":"2019/01/16/JavaScript基础/函数专题/","text":"Function：一种引用类型，和Array、Date性质一样。 每个函数都是Function类型的实例，即为一个对象，同其他引用类型的实例一样，函数实例具有属性（length（表示形参个数）、name、prototype（指向原型对象））和方法（call、apply）。 在函数内部，还有两个特殊的对象，arguments和this。 我们创建的每一个函数都有一个prototype属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。 prototype就是通过调用构造函数而创建的那个对象实例的原型对象。 创建对象的常用方法是组合使用构造函数模式和原型模式。构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。 构造函数的prototype属性指向原型对象，而原型对象的constructor指向构造函数。 构造函数的实例对象(可以说是每个对象)的[[Prototype]]指针(也即为chrome的console中打印每个对象时，里面的proto)，指向构造函数指向的原型对象。可通过Object.getPrototypeOf()标准方法访问该属性。这也就是为什么所有实例对象都能访问到同一份定义在原型对象中的内容了。 实例属性会屏蔽原型中同名属性。 当把构造函数的原型对象设置为等于一个以对象字面量形式创建的新对象时，会导致该原型对象的constructor属性指向Object构造函数，而不再是自身的构造函数。当然，可以通过修改赋值的对象字面量，为其增加一个”constructor: Person”,纠正constructor指向。","tags":[{"name":"JavaScript核心","slug":"JavaScript核心","permalink":"http://yoursite.com/tags/JavaScript核心/"}]},{"title":"判断类型专题","date":"2019-01-16T03:39:01.000Z","path":"2019/01/16/JavaScript基础/判断类型专题/","text":"typeof 对于基本类型，除了 null 都可以显示正确的类型，对于对象，除了函数都会显示 object number、string、boolean、undefined、symbol 12345typeof null // &quot;object&quot;typeof Symbol() // &apos;symbol&apos;typeof b // b 没有声明，但是还会显示 undefnedtypeof console.log // &apos;function&apos;typeof [] // &apos;object&apos; 判断复杂类型(Array, RegExp) 用instanceof 12345678910111213141516JavaScript instanceof 运算符代码:function instance_of(L, R) &#123;//L 表示左表达式，R 表示右表达式 var O = R.prototype;// 取 R 的显示原型 L = L.__proto__;// 取 L 的隐式原型 while (true) &#123; if (L === null) return false; if (O === L)// 这里重点：当 O 严格等于 L 时，返回 true return true; L = L.__proto__; // 遍历原型链 &#125; &#125;如果不想遍历原型链，即不判断父类，可以直接使用：obj.(__proto__.)constructor === Obj 使用Object.prototype.toString.call()精确的区分复杂数据类型，会输出’[object type]’ 123456&quot;toString&quot; in Object.prototype // true&quot;toString&quot; in Array.prototype // trueObject.prototype.toString() === Array.prototype.toString() // falseObject.prototype.toString.call(1); // &quot;[object Number]&quot;Object.prototype.toString.call(false); //&quot;[object Boolean]&quot;Object.prototype.toString.call(); //&quot;[object Undefined]&quot; 注意：在做表单输入验证时，从拿到的数据都是string","tags":[{"name":"JavaScript核心","slug":"JavaScript核心","permalink":"http://yoursite.com/tags/JavaScript核心/"}]},{"title":"引用型变量在使用前要先初始化，动态给obj赋值","date":"2019-01-16T03:39:01.000Z","path":"2019/01/16/JavaScript基础/引用型变量在使用前要先初始化，动态给obj赋值/","text":"引用型变量在使用前要初始化，否则它的方法不能使用；12345let obj;obj.push(1); // error: push is not defined in obj;//=================================================obj = [];obj.push(1); // ok 动态给obj赋值,实现类似Map的set(key, valye)功能123let obj = &#123;&#125;;let obj[key] = value;","tags":[{"name":"JavaScript核心","slug":"JavaScript核心","permalink":"http://yoursite.com/tags/JavaScript核心/"}]},{"title":"立即执行函数","date":"2019-01-16T03:39:01.000Z","path":"2019/01/16/JavaScript基础/立即执行函数/","text":"形式1234567标准形式：(function()&#123;&#125;)();变形： (function()&#123;&#125;()); !function()&#123;&#125;(); +function()&#123;&#125;(); -function()&#123;&#125;(); 直接使用function(){}()这种形式会报错，因为这种做法混淆了函数声明和函数调用，function本身是一个关键字，后面跟的应该是一个函数声明，因此在遇到圆括号时就会报错。因此上述所有操作的目的都是让函数声明变成函数表达式。 经测试，标准写法有更好的性能，只是需要注意括号匹配。 建议：短语句时使用标准写法，而当要封装的代码很长时，使用变形写法，更清晰，同时也不用注意括号匹配。 作用 立即执行函数本身是个函数，具有函数的作用域，与全局作用域隔离开 配合闭包，可以实现缓存(函数内部值)，实现封装(控制函数外部对函数内部变量的访问) 删除闭包中保存的变量。函数销毁（主动把函数赋为null或者页面卸载）","tags":[{"name":"JavaScript核心","slug":"JavaScript核心","permalink":"http://yoursite.com/tags/JavaScript核心/"}]},{"title":"跨浏览器事件添加函数","date":"2019-01-16T03:39:01.000Z","path":"2019/01/16/JavaScript基础/跨浏览器事件添加函数/","text":"IE和标准浏览器添加事件的方法有所不同 IE： 添加事件处理程序：target.attachEvent(on+EventType, handler); 删除事件处理程序：target.detachEvent(on+EventType, handler); others: 添加事件处理程序：target.addEventListener(EventType, handler); 删除事件处理程序：target.removeEventListener(EventType, handler); 优化过的跨浏览器的事件添加/删除函数： 保证兼容性 只判断一次 懒加载方案 12345678910111213141516171819202122232425262728293031function addHandler(target, EventType, handler)&#123; // 重写addHandler方法 if(target.addEventListener)&#123; addHandler = function()&#123; target.addEventListener(EventType, handler); &#125; &#125; else &#123; addHandler = function()&#123; target.attachEvent(&quot;on&quot;+EventType, handler); &#125; &#125; // 注意：这里并没有递归，在函数体内部已经覆盖掉了原本的函数，执行到这里的时候全局对象所属的addHandler函数已经变成上述if...else二者之一了 // 下面执行的函数也是新的了。以后再调用 addHandler()或者removeHandler()时不会再次检测，因为检测代码已经被新函数覆盖了。 addHandler(target, EventType, handler);&#125;function removeHandler(target, EventType, handler)&#123; // 重写addHandler方法 if(target.removeEventListener)&#123; removeHandler = function()&#123; target.removeEventListener(EventType, handler); &#125; &#125; else &#123; removeHandler = function()&#123; target.detachEvent(&quot;on&quot;+EventType, handler); &#125; &#125; removeHandler(target, EventType, handler);&#125; 预加载 123456789101112131415var addHandler = document.body.addEventListener? function(target, eventType, handler)&#123; target.addEventHandler(eventType, handler); &#125;: function(target, eventType, handler)&#123; target.attachEvent(&quot;on&quot;+eventType, handler); &#125;;var removeHandler = document.body.removeEventListener ? function(target, eventType, handler)&#123; target.removeEventListener(eventType, handler, false); &#125;: function(target, eventType, handler)&#123; target.detachEvent(&quot;on&quot; + eventType, handler); &#125;;","tags":[{"name":"JavaScript核心","slug":"JavaScript核心","permalink":"http://yoursite.com/tags/JavaScript核心/"}]},{"title":"EventLoop总结","date":"2019-01-16T03:39:01.000Z","path":"2019/01/16/JavaScript进阶/EventLoop总结/","text":"事件循环背景：首先，js是一门单线程非阻塞的语言。为了协调事件（event），用户交互（user interaction），脚本（script），渲染（rendering），网络（networking）等，用户代理（user agent）必须使用事件循环（event loops）。 主线程执行代码的过程中，一旦遇到异步操作，就将其挂起，交给宿主环境中的对应异步线程去执行这个事件。 一、浏览器上的EventLoop参考：什么是浏览器的事件循环（Event Loop）？ 1. 准备知识认识浏览器环境下的异步操作 宏任务： script任务、定时器任务、ajax、用户操作 微任务：Promise、MutationObserver 说明：一个 Event Loop 只有一个 Microtask Queue，即一轮事件循环结束前会清空整个微任务队列。 2. 执行过程第一轮开始 &gt;&gt; 脚本解析（第一个宏任务）：执行完所有同步代码，并初始化（启动）遇到的异步任务，如果有到期的定时器或者其他返回结果的异步任务，将结果和其回调函数放入相应的任务队列。 同步函数执行完后，执行栈（ECS）为空，现在开始从微任务队列中取任务放到执行栈中执行，执行任务的过程中，如果遇到新的宏任务或者微任务，则添加到相应的队列。直至微任务队列清空。 &lt;&lt; 第一轮结束 第二轮开始 &gt;&gt; 从宏任务队列中取一个任务放到执行栈中开始执行，执行的过程中，将遇到的宏任务/微任务放到对应的任务队列。 该宏任务执行完后，清空微任务队列 &lt;&lt; 第二轮结束 第三轮，第四轮。。。 3. 关于UI渲染 macro-task任务执行完毕，接着执行完所有的micro-task任务后，此时本轮循环结束，开始执行UI render。UI render完毕之后接着下一轮循环。 即：MacroTask=&gt;MicroTask=&gt;UI render 二、Node中的EventLoop思考：为什么同样是JavaScript，node却可以用来服务端编程？ node是JavaScript的服务端实现，node实现了一些服务端编程需要的api，比如文件操作、net相关、数据库相关，因此具备了服务端编程的能力。 思考：服务端有哪些异步事件？ 除了客户端JavaScript具有的定时器，用户操作等，还多了io操作 1. node提供了4个timer setTimeout() setInterval() setImmediate() process.nextTick() 前两个是语言的标准，后两个是node特有的。 2. node的事件循环分为6个阶段 nodejs的event loop分为6个阶段，它们会按照顺序反复运行，分别如下： 1234567891011- timers：执行setTimeout() 和 setInterval()中到期的callback。- I/O callbacks：上一轮循环中有少数(上一轮执行中超过系统限制的部分)的I/Ocallback会被延迟到这一轮的这一阶段执行，执行一些系统调用错误，比如网络通信的错误回调- idle, prepare：队列的移动，仅内部使用- poll：最为重要的阶段，执行I/O callback，在适当的条件下会阻塞在这个阶段- check：执行setImmediate的callback- close callbacks：执行close事件的callback，例如socket.on(&quot;close&quot;,func) 不同于浏览器的是，在每个阶段完成后，而不是MacroTask任务完成后，microTask队列就会被执行。这就导致了同样的代码在不同的上下文环境下(浏览器/node)会出现不同的结果。 3. 执行过程详解注意：所有异步任务的回调都是先从队列取出来，添加到ECS再执行的，也就是说，当执行异步的回调的时候，这个异步任务已经结束了，也不存在于队列中了 bootstrap阶段 &gt;&gt; 执行同步脚本，注册异步任务，完成后清空nextTick队列和microTask队列。（这就是为什么nextTick和微任务一定会比timer先执行的原因） &lt;&lt; end bootstrap阶段 EventLoop第一轮开始 &gt;&gt; 进入timer阶段：检查timer的任务队列（存放到期未处理的timer）是否为空，不为空则依次取出执行。 问题： 在执行的过程中，遇到新的异步任务怎么办？ 答：有nextTick/或者microTask类型的异步任务，将他们的结果和回调添加至相应队列，然后执行下一个到期未处理的timer回调；如果遇到新的timer，则放到下一轮；如果遇到新的io任务，一般io至少需要10ms才能ok,有可能事件循环已经又过了几轮，因此什么时候执行io的回调并不确定，一般都会晚于同时注册的timer? timer队列清空后，开始依次清空nextTick队列和microTask队列。然后进入下一个阶段。 举例说明：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869const fs = require('fs');const path = require('path');const timeoutScheduled = Date.now();setTimeout(() =&gt; &#123; let delay = Date.now() - timeoutScheduled; setTimeout(()=&gt;&#123; delay = Date.now() - timeoutScheduled; console.log(`$&#123;delay&#125;ms have passed since I was scheduled,timer`); fs.readFile(path.resolve(__dirname,'4.js'), ()=&gt;&#123; console.log('io1') &#125;); setTimeout(()=&gt;&#123; console.log('timer1'); &#125;,0); process.nextTick(()=&gt;&#123; console.log('nextTick1') &#125;) new Promise((resolve,reject)=&gt;&#123; resolve(); &#125;).then(()=&gt;&#123; console.log('promise1') &#125;) &#125;,0); setTimeout(()=&gt;&#123; delay = Date.now() - timeoutScheduled; console.log(`$&#123;delay&#125;ms have passed since I was scheduled,timer`); fs.readFile(path.resolve(__dirname,'4.js'), ()=&gt;&#123; console.log('io2') &#125;); setTimeout(()=&gt;&#123; console.log('timer2'); &#125;,0); process.nextTick(()=&gt;&#123; console.log('nextTick12') &#125;) new Promise((resolve,reject)=&gt;&#123; resolve(); &#125;).then(()=&gt;&#123; console.log('promise2') &#125;) &#125;,0); // 主线程耗时100ms，确保离开这里时，两个timer都已经过期。 let start = new Date().getTime(); while (new Date().getTime() - start &lt; 100) &#123; &#125; console.log(`$&#123;delay&#125;ms have passed since I was scheduled`);&#125;, 100);// 说明：1. 执行完第一行同步代码时，100ms的timer还未到期，因此一直往下来到poll阶段，并阻塞在这里（因为poll队列为空并且immediate队列也为空）。2. 100ms后，timer到期，跳出poll阶段，到达下一轮循环的timer阶段。3. timer队列里有两个回调函数，一个一个执行，执行过程中遇到nextTick任务和promise任务都添加到timer阶段的nextTick队列和Promise队列；遇到的timer因为超时至少1ms。4. 两个回调函数都执行完后，先清空nextTick队列，再清空Promise队列。// 输出为：100ms have passed since I was scheduled202ms have passed since I was scheduled,timer203ms have passed since I was scheduled,timernextTick1nextTick12promise1promise2timer1timer2io1io2 poll阶段，主要有2个功能： 123456789101. 处理 poll 队列的事件2. 当有已超时的 timer，执行它的回调函数even loop将同步执行poll队列里的回调，直到队列为空或执行的回调达到系统上限（上限具体多少未详），接下来even loop会去检查有无预设的setImmediate()，分两种情况：- 若有预设的setImmediate(), event loop将结束poll阶段进入check阶段，并执行check阶段的任务队列- 若没有预设的setImmediate()，event loop将阻塞在该阶段等待注意一个细节，没有setImmediate()会导致event loop阻塞在poll阶段，这样之前设置的timer岂不是执行不了了？所以咧，在poll阶段event loop会有一个检查机制，检查timer队列是否为空，如果timer队列非空，event loop就开始下一轮事件循环，即重新进入到timer阶段。 &lt;&lt; 第一轮结束 第二轮开始 &gt;&gt; 从宏任务队列中取一个任务放到执行栈中开始执行，执行的过程中，将遇到的宏任务/微任务放到对应的任务队列。 该宏任务执行完后，清空微任务队列 &lt;&lt; 第二轮结束 第三轮，第四轮。。。 以下两个输出的顺序是不固定的，因为Node对timer的过期检查不一定靠谱，它会受机器上其它运行程序影响，或者那个时间点主线程不空闲。 12345678910111213setTimeout(() =&gt; &#123; console.log('timeout')&#125;, 0)setImmediate(() =&gt; &#123; console.log('immediate')&#125;)// 先输出timeout后输出immediate的原因：// 初始化脚本+执行同步代码的时间&gt;1ms，因此处理完这些后，timeout已经过期，就在一次事件循环中，先执行timer后执行immediate了// 先输出immediate后输出timeout的原因：// 初始化脚本+执行同步代码的时间&lt;1ms，因此处理完这些后，timeout还未过期，就离开timer阶段，执行immediate了。在下一轮事件循环中，执行到期的timer 解释以下以下问题：1234567891011121314151617// 第二轮setTimeout(() =&gt; console.log(1),0);setImmediate(() =&gt; console.log(2));// 第一轮process.nextTick(() =&gt; console.log(3));Promise.resolve().then(() =&gt; console.log(4));(() =&gt; console.log(5))();let start = new Date().getTime();while(new Date().getTime() - start &lt; 1000)&#123;&#125;// 输出为：53412 问题：1000ms以后，所有异步任务都已经有了结果，按照从timer往后的顺序，为什么输出不是：5 1 3 4 2 答案：这要从node的bootstrap阶段到eventloop阶段说起。 参考：node源码粗读 node源码粗读（9）：nextTick、timers API、MicroTasks注册到执行全阶段解读 1. Environment::Start 在这里不做过多详细介绍了，之前的文章中介绍过很多。有一个知识点需要注意就是：Immediate是在这个阶段注册到uv_check_start中的。此Immediate其实是Environment::CheckImmediate函数，保证之后event-loop在运行的时候能在check阶段运行这个函数，进而触发immediate_callback_function实现对ImmediateList的调用。至于idle部分，是为了在有ImmediateList的时候直接跳过poll阶段，毕竟poll是阻塞运行的。 2. bootstrap阶段 bootstrap阶段是node运行时候的构建阶段，也是最基础的阶段。bootstrap阶段会把整体的node架子搭起来（在这里不做详细介绍），之后运行业务代码。比如本文中的这个例子，上图中画的应该也比较清晰了，顺序执行。唯一的区别是：在执行不同API的时候，callback的去向是不一致的。从上图中也能看出来，这几个API最终的去向分别是：TimersList、microTask、immediateQueue、nextTickQueue。 其中，setTimeout在注册的时候会创建TimerWrap的实例，在创建实例的时候会初始化uv_timer，之后再通过TimerWrap.start启动uv_timer_start，开始监听，到时间触发运行回调函数： ==nextTick在注册之后且bootstrap构建结束后运行SetupNextTick函数，从而触发nextTick的运行，而nextTick在运行之后会触发runMicroTasks()，清空bootstrap阶段的microTask==： 即：首次运行时，nextTick和microTask是在进入事件循环之前就已经被清空了。 3. event-loop阶段 在bootstrap之后便进入了event-loop。event-loop第一个阶段便是timers，在这里如果有到时间的Timer，便会触发OnTimeout，OnTimeout会触发InternalMakeCallback从而执行TimersList中的函数。而在执行完后还会触发InternalCallbackScope::Close，在这个函数中会触发nextTick，在触发nextTick后触发microTasks。==setTimeout简易流程如下==： 也正是InternalMakeCallback和InternalCallbackScope::Close使得libuv和v8紧紧的联系在了一起，一方面可以通过setTimeout来设置运行时间；另一方面又可以在setTimeout的回调中书写js代码。","tags":[{"name":"JavaScript核心","slug":"JavaScript核心","permalink":"http://yoursite.com/tags/JavaScript核心/"}]},{"title":"关于数组的forEach和map方法","date":"2019-01-16T03:39:01.000Z","path":"2019/01/16/JavaScript基础/关于数组的forEach和map方法/","text":"错误的理解1234567var bb = [1,2,3,5];bb.forEach((item)=&gt;&#123;item = 3&#125;); bb; // [1, 2, 3, 5]var bb = [&#123;key:1&#125;,&#123;key:2&#125;];bb.forEach((item)=&gt;&#123;item.key =3&#125;);bb; // [&#123;key: 3&#125;,&#123;key: 3&#125;] 因为forEach和map一样，返回的是一个新的数组。 错解分析：因为item是数组元素的一个拷贝，类似函数传参。当item为基本类型时，拷贝的是副本，当为复杂类型时为引用。 正确的理解原文: JavaScript — Map vs. ForEach - What’s the difference between Map and ForEach in JavaScript? 如果你已经有使用JavaScript的经验，你可能已经知道这两个看似相同的方法：Array.prototype.map()和Array.prototype.forEach()。 那么，它们到底有什么区别呢？ 定义我们首先来看一看MDN上对Map和ForEach的定义： forEach(): 针对每一个元素执行提供的函数(executes a provided function once for each array element)。 map(): 创建一个新的数组，其中每一个元素由调用数组中的每一个元素执行提供的函数得来(creates a new array with the results of calling a provided function on every element in the calling array)。 到底有什么区别呢？forEach()方法不会返回执行结果，而是undefined。也就是说，forEach()会修改原来的数组，而map()方法会得到一个新的数组并返回。 关于forEach(item,index,arr)会修改原来数组的解释： 当item为基本类型时：通过arr[index]修改 当item为复杂类型时：直接修改item即可 示例下方提供了一个数组，如果我们想将其中的每一个元素翻倍，我们可以使用map和forEach来达到目的。12345678910111213let arr = [1, 2, 3, 4, 5];// ForEach:arr.forEach((num, index) =&gt; &#123; return arr[index] = num * 2;&#125;);//执行结果如下：// arr = [2, 4, 6, 8, 10]// Map:let doubled = arr.map(num =&gt; &#123; return num * 2;&#125;);//执行结果如下：// doubled = [2, 4, 6, 8, 10] 执行速度对比可以看到，在我到电脑上forEach()的执行速度比map()慢了70%。 函数式角度的理解如果你习惯使用函数是编程，那么肯定喜欢使用map()。因为forEach()会改变原始的数组的值，而map()会返回一个全新的数组，原本的数组不受到影响。 哪个更好呢？取决于你想要做什么。 forEach适合于你并不打算改变数据的时候，而只是想用数据做一些事情 – 比如存入数据库或则打印出来。 12345678let arr = ['a', 'b', 'c', 'd'];arr.forEach((letter) =&gt; &#123; console.log(letter);&#125;);// a// b// c// d map()适用于你要改变数据值的时候。不仅仅在于它更快，而且返回一个新的数组。这样的优点在于你可以使用复合(composition)(map(), filter(), reduce()等组合使用)来玩出更多的花样。 12345// 我们首先使用map将每一个元素乘以2，然后紧接着筛选出那些大于5的元素。最终结果赋值给arr2。let arr = [1, 2, 3, 4, 5];let arr2 = arr.map(num =&gt; num * 2).filter(num =&gt; num &gt; 5);// arr2 = [6, 8, 10] 核心要点 能用forEach()做到的，map()同样可以。反过来也是如此。 map()会分配内存空间存储新数组并返回，forEach()不会返回数据。 forEach()允许callback更改原始数组的元素。map()返回新的数组。","tags":[{"name":"JavaScript核心","slug":"JavaScript核心","permalink":"http://yoursite.com/tags/JavaScript核心/"}]},{"title":"JS垃圾回收相关","date":"2019-01-16T03:39:01.000Z","path":"2019/01/16/JavaScript进阶/JS垃圾回收相关/","text":"首先，js中使用的内存分为两种：栈内存和堆内存。 栈内存：即为保存函数执行上下文ECS的栈空间。EC里面包括基本类型数据的值，引用类型数据的引用地址。 堆内存：保存引用类型的真实值，具体表现来说：对象以key：value形式保存，函数以字符串形式保存。 接着看看他们二者的释放过程 栈内存：在函数执行时会产生一个新的执行上下文，压入上下文栈，执行完毕后出栈，对应的栈空间就被释放了。但是如果当前执行上下文中的部分内存被该作用域以外的东西引用，那么当前的这个作用域就不能销毁了？？？活动变量？？？查清楚！！！ 堆内存：当一块内存区域不存在任何引用时，就认为它是可以被释放的，浏览器将在空闲时间回收。","tags":[{"name":"JavaScript核心","slug":"JavaScript核心","permalink":"http://yoursite.com/tags/JavaScript核心/"}]},{"title":"H5 service worker","date":"2019-01-16T03:39:01.000Z","path":"2019/01/16/JavaScript进阶/H5 service worker/","text":"service worker出现的原因：native应用比web应用更受青睐的主要原因就是，在没有通过网络接收到更多的数据前，仍可以提供基本的功能。 之前的解决方案AppCacheAppCache通过在html页面的HTML标签上增加manifest属性，这个属性值与缓存清单文件关联。 应该在每个意图缓存的页面上添加manifest特性。同时，你也不需要在清单文件中列出所有你想缓存的页面。浏览器会自动的将带有manifest属性的页面缓存。 具体使用细节请参考AppCache service worker通过navigator.serviceWorker注册一个serviceworker的url，然后就可以在serviceworker的文件中通过监听一些事件做一些行为。 使用步骤： 通常遵循以下基本步骤来使用 service workers： service worker URL 通过serviceWorkerContainer.register() 来获取和注册。 如果注册成功，service worker 就在 ServiceWorkerGlobalScope 环境中运行； 这是一个特殊类型的 woker 上下文运行环境，与主运行线程（执行脚本）相独立，同时也没有访问 DOM 的能力。 service worker 现在可以处理事件了。 受 service worker 控制的页面打开后会尝试去安装 service worker。最先发送给 service worker 的事件是安装事件(在这个事件里可以开始进行填充 IndexDB和缓存站点资源)。这个流程同原生 APP 或者 Firefox OS APP 是一样的 — 让所有资源可离线访问。 当 oninstall 事件的处理程序执行完毕后，可以认为 service worker 安装完成了。 下一步是激活。当 service worker 安装完成后，会接收到一个激活事件(activate event)。 onactivate 主要用途是清理先前版本的service worker 脚本中使用的资源。 Service Worker 现在可以控制页面了，但仅是在 register() 成功后的打开的页面。也就是说，页面起始于有没有 service worker ，且在页面的接下来生命周期内维持这个状态。所以，页面不得不重新加载以让 service worker 获得完全的控制。","tags":[{"name":"JavaScript核心","slug":"JavaScript核心","permalink":"http://yoursite.com/tags/JavaScript核心/"}]},{"title":"JavaScript原型链","date":"2019-01-16T03:39:01.000Z","path":"2019/01/16/JavaScript进阶/JavaScript原型链/","text":"ECMAScript 中描述了原型链的概念，并将原型链作为实现继承的主要方法。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。 简单回顾一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。 那么，假如我们让原型对象等于另一个类型的实例，结果会怎么样呢？显然，此时的原型对象（另一个类的实例）将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。这就是所谓原型链的基本概念。 理清Function、Object的关系 首先明确：Function、Object都是构造函数，是函数就有prototype属性。 所有函数都是Function构造函数的实例，因此所有函数都是对象，即都有__proto__属性。 所有对象都是Object的实例，且都有__proto__属性。 由于Object是一个函数，即为Function的实例，因此有： Object.__proto__ === Function.prototype 由于Function是一个函数，所有函数都是Function的实例，因此Function为一个对象,就有： Function.__proto__ === Function.prototype 1234补充： 一般情况下：obj.__proto__ === Obj.prototype 由以上Function.__proto__ === Function.prototype知： Function的构造函数是Function，即Function自己构造了自己。 由以上得出： Object.__proto__ === Functin.prototype === Function.__proto__","tags":[{"name":"JavaScript核心","slug":"JavaScript核心","permalink":"http://yoursite.com/tags/JavaScript核心/"}]},{"title":"JavaScript返回一个函数（闭包）的使用场景","date":"2019-01-16T03:39:01.000Z","path":"2019/01/16/JavaScript进阶/JavaScript返回一个函数（闭包）的使用场景/","text":"1. 在内存中维持变量：如果缓存数据、柯里化。2. 批量制造函数或者需要返回一个函数的时候3. 循环绑定事件:12345678910111213141516let arr = [];for (var i = 0; i &lt; 5; i++) &#123; arr.push(() =&gt; &#123; console.log(i) &#125;)&#125;arr.forEach(f =&gt; f()); // 全输出5// ====================================// 先执行new，再执行`.`运算符new Array(5).forEach((item,index) =&gt; &#123; arr.push(() =&gt; &#123; console.log(index) &#125;)&#125;)arr.forEach(f =&gt; f()); // 0，1，2，3，4 因此不建议在 for 循环中建立函数，而是使用数组的 forEach 方法，但是不兼容 IE678 ，需要额外添加 forEach 方法；","tags":[{"name":"JavaScript核心","slug":"JavaScript核心","permalink":"http://yoursite.com/tags/JavaScript核心/"}]},{"title":"nodeParty总结","date":"2019-01-16T03:39:01.000Z","path":"2019/01/16/JavaScript进阶/nodeParty总结/","text":"docker部署nodejs项目MQTT协议实现长连接服务端渲染SSR，nodejs项目架构node异步原理BIO（block IO）、NIO（New IO）、AIO（Async IO）参考：初探 Node.js 的异步 I/O 实现","tags":[{"name":"JavaScript核心","slug":"JavaScript核心","permalink":"http://yoursite.com/tags/JavaScript核心/"}]},{"title":"typescript的变量定义","date":"2019-01-16T03:39:01.000Z","path":"2019/01/16/JavaScript进阶/typescript的变量定义/","text":"类变量面向对象编程时，实例的属性可以通过set方法或者构造器赋值。12345678910class A &#123; private name: string; construtor(name)&#123; this.name = name; &#125; func1()&#123; console.log(this.name); // ?? &#125;&#125; 类变量有默认值么？ 局部变量务必记住给要使用的对象初始化。12345678910let arr:string[];arr.push(&apos;a&apos;);//============ 等价于 ===================let arr;arr.push(&apos;a&apos;); // Cannot read property &apos;push&apos; of undefined// 因为使用let声明一个变量后，在没有给他赋值的情况下它的值是undefined。因此也就没有push方法。let arr:string[] = [];arr.push(&apos;a&apos;);console.log(arr); // [&apos;a&apos;] 因此要养成初始化变量的习惯。 遍历对象当对象的key是一个变量时，只能使用obj[key]而不能使用obj.key。当然二者可以合法混用。 12345678910111213141516let obj = &#123; person1:&#123; name: &apos;wangdian&apos;, age: 24, sex: &apos;male&apos; &#125;, person2:&#123; name: &apos;wangdian&apos;, age: 24, sex: &apos;male&apos; &#125;&#125;for (let key in obj)&#123;// console.log(obj.key); // undefined console.log(obj[key].name);&#125;","tags":[{"name":"JavaScript核心","slug":"JavaScript核心","permalink":"http://yoursite.com/tags/JavaScript核心/"}]},{"title":"this相关问题","date":"2019-01-16T03:39:01.000Z","path":"2019/01/16/JavaScript进阶/this相关问题/","text":"对this的概括： this是执行上下文（Execution Context）的一个重要属性，是一个与执行上下文相关的特殊对象。因此，它可以叫作上下文对象（也就是用来指明执行上下文是在哪个上下文中被触发的对象）。 this不是变量对象（Variable Object）的一个属性，所以跟变量不同，this从不会参与到标识符解析过程。也就是说，在代码中当访问this的时候，它的值是直接从执行上下文中获取的，并不需要任何作用域链查找。this的值只在进入上下文的时候进行一次确定。 this的确定方法： 全局上下文中：无论是否在严格模式下，在全局执行上下文中（在任何函数体外部）this 都指代全局对象。 函数上下文：在function内部出现this，this的值取决于函数被调用的方式。 function作为对象的方法调用：指向调用的对象 function作为构造函数：指向new出的对象 function作为无上下文的函数：也就是说这些函数没有绑定到特定的对象上，那么这些上下文无关的函数将会被默认的绑定到global object上。比如：闭包和立即执行函数。 作为eventhaddler时：指向触发事件的页面元素对象 this的问题解决 var that = this； 函数的bind方法 箭头函数 函数作为参数时，参数函数里面的this指向？当函数作为参数时，这个函数便失去了所属对象信息，单纯作为一个函数。因此，在调用者内部执行该函数的时候，该函数里面的this指向global对象。 箭头函数的this 箭头函数执行时，自身（本函数）没有this，因此如果使用this的话会当作普通变量从作用域查找。 作为对比，普通function函数执行时，由于其执行上下文中必定有this，因此永远不会去作用域链查找this。因此，this值也就取决于执行上下文建立的那一刻，也就是当函数被调用，但是开始执行函数内部代码之前。 123456789101112131415161718192021222324252627282930313233343536373839404142补充：上下文创建和代码执行阶段的EC // demo function foo(i) &#123; var a = &apos;hello&apos;; var b = function privateB() &#123;&#125;; function c() &#123;&#125;&#125;foo(22); // 创建EC，代码未执行 fooExecutionContext = &#123; scopeChain: &#123; ... &#125;, variableObject: &#123; arguments: &#123; 0: 22, length: 1 &#125;, i: 22, c: pointer to function c() a: undefined, b: undefined &#125;, this: &#123; ... &#125;&#125;// 代码开始执行时fooExecutionContext = &#123; scopeChain: &#123; ... &#125;, variableObject: &#123; arguments: &#123; 0: 22, length: 1 &#125;, i: 22, c: pointer to function c() a: &apos;hello&apos;, b: pointer to function privateB() &#125;, this: &#123; ... &#125;&#125; 对象里面没有this：由于this是函数的执行上下文中的变量，因此只有在函数内才有this。 123456789101112var obj = &#123; a: ()=&gt;&#123;console.log(this);&#125;&#125;;obj.a(); // global objectvar obj2 = &#123; a: function()&#123; console.log(this); (()=&gt;&#123;console.log(this);&#125;)(); &#125;&#125;;obj2.a(); // obj2, obj2","tags":[{"name":"JavaScript核心","slug":"JavaScript核心","permalink":"http://yoursite.com/tags/JavaScript核心/"}]},{"title":"关于继承","date":"2019-01-16T03:39:01.000Z","path":"2019/01/16/JavaScript进阶/关于继承/","text":"类的继承按照功能划分为：继承类的私有属性、继承类的公有属性、继承类的静态属性ES5的继承：私有属性的继承：12345678910//核心思想：通过调用父类的构造函数实现function Parent()&#123; this.age = 40;&#125;function Child()&#123; // 直接调用，会导致Parent的this指向window，age会挂在window下面 // Parent(); Parent.call(this); // 相当于执行 this.age = 40; this.name = 'child';&#125; 公有属性的继承：(目的：访问到父类原型上的属性，即: 使 子类原型(Child.prototype) 的proto指向父类原型)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657function Parent()&#123; this.age = 40;&#125;Parent.prototype.eat = function()&#123; console.log('eat');&#125;function Child()&#123; this.name = 'child';&#125;// 错误的继承方式,因为这样会使子类原型指向父类原型，一旦修改子类原型，父类也会受到影响。// Child.prototype = Parent.prototype;1) 法一： Child.prototype.__proto__ = Parent.prototype;2) 法一（ES6版本）：Object.setPrototypeOf(Child.prototype, Parent.prototype); // 完全等价于法一，只是这个方法是ES6的。3) 法二：Child.prototype = Object.creat(Parent.prototype);/* * 法二的原理：创建一个中转对象，使该对象的__proto__指向父类原型，constructor指向子类构造器 function creat(parentPrototype)&#123; let Fn = function()&#123;&#125;; Fn.prototype = parentPrototype; return new Fn(); &#125;*/注：法二会带来一个问题，中转对象并没有constructor指针，因此Child的实例在访问constructor的时候，最终所指向是父类原型上的constructor的指向，即为Parent函数！如何纠正constructor指向：a. Child.prototype = Object.creat(Parent.prototype, &#123; constructor:&#123;value:Child&#125;&#125;)// 自己实现一个Objec.create函数b. function create(parentPrototype, props)&#123; let Fn = function()&#123;&#125;; Fn.prototype = parentPrototype; let fn = new Fn(); // fn的__proto__已经指向了parentPrototype for(let key in props)&#123; Object.defineProperty(fn, key, &#123; ...props[key], enumberable:true,// 表示是否可以被枚举（默认false） // configurable:true, // 表示是否可以被删除(默认true) // writable:true, // 是否可被修改 // value: 1, // 值 // 注意：get/set 不能与writable和valu一起使用 // get()&#123;&#125;, // set()&#123;&#125; &#125;); // 也可以使用fn[key]=props[key]; 只是此时，传递的参数要改为&#123;constructor:Child&#125; &#125; return fn; &#125;eg: Child.prototype = creat(Parent.prototype, &#123;constructor:&#123;value:Child&#125;&#125;); // 注意：constructor的值是一个以value为key的对象let child = new Child();console.log(child.constructor);parent.__proto__.eat 和 parent.eat 区别：二者都能找到原型上的eat方法，区别在于前者会直接在原型上面查找eat方法，后者先会查找实例上的方法有没有eat，没有的话会继续往原型上找。 补充： 法一的继承图示： 法二的继承图示： 红色的线代表初始状态，紫色的线代表继承状态，浅蓝色的线代表构造器指示状态 继承公有属性和私有属性（一般不使用）：12核心思想：让子类的原型等于父类的实例，这样就能访问到父类实例上的属性和原型上的属性；也需要修正constructor；Child.prototype = new Parent(); 注：函数声明和函数表达式的一个区别 function a(){} 此时，可以通过a获取该函数的引用 let aa = function b(){} 此后，可以在函数外部通过aa获得函数的引用，但不能通过b获得, 但是可以在函数内部通过b获得函数的引用。 ES6，class的继承(继承全部属性：私有、公有、静态)12345678910111213141516171819202122class Parent&#123; constructor()&#123; this.name = &apos;parent&apos;; &#125; eat()&#123; console.log(&apos;eat&apos;); &#125;&#125;class Child extends Parent&#123; static aa = 1; // 静态属性（ES7支持） constructor()&#123; this.age = 9; // 私有属性 &#125; smoking()&#123; // 原型上的方法 console.log(&apos;smoking&apos;) &#125; static a()&#123; // 属于类上的方法 return 1; &#125;&#125; 关于Object.create()12345678910111213141516171819202122// 使子类原型（就是个普通对象）的__proto__指向父类原型// prototype也好__proto__也好，都是一个引用（指针）function creat(parentProto) &#123; let F = function () &#123; &#125;; // 从这里可以看到，creat生产的（中间）普通对象的__proto__指向父类原型，因此，子类生产的实例所调用的constructor为父类的prototype中的constructor，即指向父类构造函数。 F.prototype = parentProto; return new F();&#125;function B() &#123; this.a = 1;&#125;function A ()&#123;&#125;B.prototype = creat(A.prototype);let b = new B();// 指向父类构造函数console.log(b.constructor); // [Function: A] 总结 其实，说了这么多，关于公有属性的继承，即基于原型链的继承，他的目的就是：使子类构造函数的原型对象的proto属性指向父类的原型对象。 因此，要修改子类原型对象的constructor指向 关于create函数的实现，之所以使用一个构造函数F来产生一个对象，而不是直接使用一个空对象，主要原因还是因为要避开直接操作proto属性。 123456789101112131415161718function create(parentProto)&#123; let proto = &#123;&#125;; proto.__proto__ = parentProto; return proto; &#125;其实完全等价于：function create(parentProto)&#123; let F = function()&#123;&#125;; F.prototype = parentProto; return new F();&#125;也等价于：Child.prototype.__proto__ = Parent.prototype;也等价于：Child.prototype = Object.setPrototypeOf(Child.prototype, Parent.prototype) 关于new操作符和继承 new内部一定使用了原型机制 12345678对一个构造函数F执行new的时候，会发生以下动作：1. let proto = Object.create(F.prototype); // 接触该构造函数的原型链2. let res = F.apply(proto, arguments); // 挂载私有属性, 注意！构造函数可能有显式返回值，没有的话默认返回this// 忽略构造函数返回的基本类型值，若返回object类型，则使用它3. return (typeof res === 'object') &amp;&amp; res || proto;","tags":[{"name":"JavaScript核心","slug":"JavaScript核心","permalink":"http://yoursite.com/tags/JavaScript核心/"}]},{"title":"函数作用域确定","date":"2019-01-16T03:39:01.000Z","path":"2019/01/16/JavaScript进阶/函数作用域确定/","text":"函数的作用域是在定义后就确定了的，不是在执行时确定的。看当前函数是在哪个作用域下定义的，那么他的上级作用域就是谁，和函数在哪执行没有关系。 1234567891011121314function fn()&#123; var tmp = 100; return function()&#123; return tmp; &#125;&#125;var f = fn();f(); // 100!function()&#123; var tmp = 200; f(); // 100&#125;();","tags":[{"name":"JavaScript核心","slug":"JavaScript核心","permalink":"http://yoursite.com/tags/JavaScript核心/"}]},{"title":"函数的作用域是在定义时就已经决定了，不是在运行时。","date":"2019-01-16T03:39:01.000Z","path":"2019/01/16/JavaScript进阶/函数的作用域是在定义时就已经决定了，不是在运行时。/","text":"Ⅰ.函数是在定义的时候确定了自由变量的作用域，而不是在调用的时候 Ⅱ.函数每调用一次，就会产生一个上下文环境 Ⅲ.函数执行完之后，上下文环境就被销毁 1234567891011121314151617181920var func1 = function()&#123; var a =1 ; function b()&#123; console.log(a); &#125; b();&#125;func1(); // 1;=================================var ccc = 2;var func2 = function(fun)&#123; var ccc = 1; fun();&#125;var func3 = function()&#123; console.log(ccc);&#125;;func2(func3); // 2;","tags":[{"name":"JavaScript核心","slug":"JavaScript核心","permalink":"http://yoursite.com/tags/JavaScript核心/"}]},{"title":"对象的方法调用之call、apply中this传递的作用","date":"2019-01-16T03:39:01.000Z","path":"2019/01/16/JavaScript进阶/对象的方法调用之call、apply中this传递的作用/","text":"当调用的函数作为对象的方法时，推荐使用call或者apply方法 形式为：someObj.someFunction.call(anotherObj, var1…) 比如想要使用数组的slice方法: Array.prototype.slice(var1, var2); 可以采用： Array.prototype.slice.call(obj, var1, var2); [].slice.call(obj, var1, var2); 显然，slice方法是Array的原型对象上的方法。意味着所有Array的实例都可以通过原型链查找到此方法。也即是说，可以以这种方式使用slice方法； [1,2,3,4].slice(1, 3); // [2,4] 但是，如果一个函数不位于原型对象中，而是仅仅作为某个特定对象的方法，此时，要想使用此方法时，只能使用someObj.someFunction(var1…); 然而，如果这个someFunction()的作用是对其宿主对象进行某些操作，即与宿主对象紧耦合的情况下，想把它分离出来复用，就不能再使用someObj.someFunction(var1…),只能使用someObj.someFunction.call/apply(anotherObj, var1…)。 综上，call和apply的作用其实是让对象的方法与其宿主对象解耦，便于另一个对象使用。而如果一个函数并不需要上下文，即与其宿主对象没有交互，此时可以直接使用someObj.someFunction(var1…)调用。 所以call、apply多适用于：同一个构造函数的不同实例，使用该构造函数原型对象的方法（公有方法），或者只是想切换this。 再比如，Object构造函数原型上有一个toString方法，即Object.prototyoe.toString()，所有Object的实例都可以使用此方法，然而其他诸如String、Boolean的实例可以通过call来使用：Object.prototyoe.toString.call(&#39;test&#39;)","tags":[{"name":"JavaScript核心","slug":"JavaScript核心","permalink":"http://yoursite.com/tags/JavaScript核心/"}]},{"title":"异步解决方案","date":"2019-01-16T03:39:01.000Z","path":"2019/01/16/JavaScript进阶/异步解决方案/","text":"解决异步的方案 高阶函数 函数是一等公民，函数可以当作参数，函数可以返回函数（偏函数，函数柯里化）callback Promise generator + co async + await 目标：写起来越来越像同步代码 高阶函数需要批量产生一些方法： 12345678function isType（type）&#123; return function（content）&#123; let t = Object.prototype.toString.call(content).replace(/\\[object\\s|\\]/g,&apos;&apos;); return t === type; &#125;&#125;let isString = isType(&apos;String&apos;);isString(&apos;bac&apos;); 回调函数： 比如：执行一个函数 调用3次后 在执行另一个函数 ;12345678910111213function after(times, callback)&#123; return function()&#123; if(--times === 0)&#123; callback(); &#125; &#125;&#125;let eat = after(3, function()&#123; console.log(&apos;eat&apos;);&#125;);eat();eat();eat(); // eat 比如：等待多个异步事件都返回后才执行某个函数，类似于Promise.all([])的功能。1234567891011121314function after(times, callback)&#123; let arr = []; return function(data)&#123; arr.push(data); if(times === arr.length)&#123; callback(); &#125; &#125;&#125;let eat = after(3, function()&#123; console.log(&apos;eat&apos;);&#125;);然后在每个异步任务的回调里面执行eat(); promise注：这里我们再说一遍，实际上 Promise#catch 只是 promise.then(undefined, onRejected); 方法的一个别名而已。 也就是说，这个方法用来注册当promise对象状态变为Rejected时的回调函数。 Promise详解 因此链式调用的最佳使用方法： then里面只放入onFulfilled回调函数，失败的情况统一在catch里面处理。 链式调用，且需要传值时，上一级onFulfilled函数要return一个promise或一个普通值，没有显式return的时候默认return undefined。 如果上级then产生了异常，则后面的成功回调都不会执行。失败结果会到达catch或者then的reject回调。 如果需要在then中置失败，不要用throw而是用Promise.reject(); 12345678910111213141516171819 function taskA() &#123; console.log(&quot;Task A&quot;);&#125;function taskB() &#123; console.log(&quot;Task B&quot;);&#125;function onRejected(error) &#123; console.log(&quot;Catch Error: A or B&quot;, error);&#125;function finalTask() &#123; console.log(&quot;Final Task&quot;);&#125;var promise = Promise.resolve();promise .then(taskA) .then(taskB) .catch(onRejected) .then(finalTask); 我们没有为 then 方法指定第二个参数(onRejected)，也可以像下面这样来理解。 then注册onFulfilled时的回调函数 catch注册onRejected时的回调函数 再看一下 上面的流程图 的话，我们会发现 Task A 和 Task B 都有指向 onRejected 的线出来。 这些线的意思是在 Task A 或 Task B 的处理中，在下面的情况下就会调用 onRejected 方法。 发生异常的时候 返回了一个Rejected状态的promise对象","tags":[{"name":"JavaScript核心","slug":"JavaScript核心","permalink":"http://yoursite.com/tags/JavaScript核心/"}]},{"title":"跨域问题总结","date":"2019-01-16T03:39:01.000Z","path":"2019/01/16/http/跨域问题总结/","text":"同一个域的定义：协议名+主机名+端口号 相同。什么导致了跨域：运行的js脚本跟所访问的资源不在同一个域。比如：前台项目和后台项目分别打包部署在不同的服务器。为什么要跨域： 浏览器为了安全，有一个同源策略。它会禁止使用从不同域加载到的数据。几种跨域方法 JSONP：jsonp 全称是JSON with Padding,即内嵌的json，凡是拥有scr这个属性的标签都可以跨域例如，\\,\\ CORS：服务端处理 postMessage、onMessage","tags":[{"name":"JavaScript核心","slug":"JavaScript核心","permalink":"http://yoursite.com/tags/JavaScript核心/"}]},{"title":"nginx","date":"2019-01-16T03:39:01.000Z","path":"2019/01/16/杂项/nginx/","text":"主要用途：1. http服务器（静态资源服务器）2. 反向代理3. 负载均衡4. 隐藏后端设施反向代理的配置在http节点下，使用upstream配置服务地址，使用server的location配置代理映射。 1234567891011121314upstream my_server &#123; // 配置服务器地址 server 10.0.0.2:8080; keepalive 2000;&#125;server &#123; listen 80; server_name 10.0.0.1; // 客户端请求的地址 client_max_body_size 1024M; location /my/ &#123; proxy_pass http://my_server/; // 转向目标服务器 proxy_set_header Host $host:$server_port; // 给响应添加nginx本身的host和port，起到隐藏后部服务设施的目的 &#125;&#125; 通过该配置，访问nginx地址http://10.0.0.1:80/my的请求会被转发到my_server服务地址http://10.0.0.2:8080/。 需要注意的是，如果按照如下配置： 1234567891011121314upstream my_server &#123; server 10.0.0.2:8080; keepalive 2000;&#125;server &#123; listen 80; server_name 10.0.0.1; client_max_body_size 1024M; location /my/ &#123; proxy_pass http://my_server; proxy_set_header Host $host:$server_port; &#125;&#125; 那么，访问nginx地址http://10.0.0.1:80/my的请求会被转发到my_server服务地址http://10.0.0.2:8080/my。这是因为proxy_pass参数中如果不包含url的路径，则会将location的pattern识别的路径作为绝对路径。","tags":[{"name":"nginx","slug":"nginx","permalink":"http://yoursite.com/tags/nginx/"}]},{"title":"分布式系统中常用的开源组件","date":"2019-01-16T03:39:01.000Z","path":"2019/01/16/杂项/分布式系统中常用的开源组件/","text":"分布式消息队列kafka，rabbitMQ（发布订阅）分布式服务管理框架zookeeper(一致性管理)分布式系统基础架构：Hadoop（存储和计算） Hadoop的框架最核心的设计就是：HDFS和MapReduce。HDFS为海量的数据提供了存储，而MapReduce则为海量的数据提供了计算。","tags":[{"name":"分布式","slug":"分布式","permalink":"http://yoursite.com/tags/分布式/"}]}]