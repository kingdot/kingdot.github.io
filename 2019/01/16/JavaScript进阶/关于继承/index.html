<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="木丁夕雨何的博客"><meta name="keywords" content="木丁夕雨何 王点 wangdian"><title>关于继承 | 木丁夕雨何</title><link rel="stylesheet" type="text/css" href="//fonts.neworld.org/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">关于继承</h1><a id="logo" href="/.">木丁夕雨何</a><p class="description">镰仓の猫</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">关于继承</h1><div class="post-meta"><a href="/2019/01/16/JavaScript进阶/关于继承/#comments" class="comment-count"><i id="changyan_count_unit" data-xid="2019/01/16/JavaScript进阶/关于继承/"></i>留言,<i id="changyan_parti_unit" data-xid="2019/01/16/JavaScript进阶/关于继承/"></i>参与</a><p><span class="date">Jan 16, 2019</span><span><a href="/categories/JavaScript/" class="category">JavaScript</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h5 id="类的继承按照功能划分为：继承类的私有属性、继承类的公有属性、继承类的静态属性"><a href="#类的继承按照功能划分为：继承类的私有属性、继承类的公有属性、继承类的静态属性" class="headerlink" title="类的继承按照功能划分为：继承类的私有属性、继承类的公有属性、继承类的静态属性"></a>类的继承按照功能划分为：继承类的私有属性、继承类的公有属性、继承类的静态属性</h5><h3 id="ES5的继承："><a href="#ES5的继承：" class="headerlink" title="ES5的继承："></a>ES5的继承：</h3><h5 id="私有属性的继承："><a href="#私有属性的继承：" class="headerlink" title="私有属性的继承："></a>私有属性的继承：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//核心思想：通过调用父类的构造函数实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">40</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 直接调用，会导致Parent的this指向window，age会挂在window下面</span></span><br><span class="line">    <span class="comment">// Parent(); </span></span><br><span class="line">    Parent.call(<span class="keyword">this</span>); <span class="comment">// 相当于执行 this.age = 40;</span></span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'child'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="公有属性的继承：-目的：访问到父类原型上的属性，即-使-子类原型-Child-prototype-的proto指向父类原型"><a href="#公有属性的继承：-目的：访问到父类原型上的属性，即-使-子类原型-Child-prototype-的proto指向父类原型" class="headerlink" title="公有属性的继承：(目的：访问到父类原型上的属性，即: 使 子类原型(Child.prototype) 的proto指向父类原型)"></a>公有属性的继承：(目的：访问到父类原型上的属性，即: 使 <em>子类原型(Child.prototype)</em> 的<strong>proto</strong>指向父类原型)</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">40</span>;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'eat'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'child'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 错误的继承方式,因为这样会使子类原型指向父类原型，一旦修改子类原型，父类也会受到影响。</span></span><br><span class="line"><span class="comment">// Child.prototype = Parent.prototype;</span></span><br><span class="line"><span class="number">1</span>) 法一： Child.prototype.__proto__ = Parent.prototype;</span><br><span class="line"><span class="number">2</span>) 法一（ES6版本）：<span class="built_in">Object</span>.setPrototypeOf(Child.prototype, Parent.prototype); <span class="comment">// 完全等价于法一，只是这个方法是</span></span><br><span class="line">ES6的。</span><br><span class="line"><span class="number">3</span>) 法二：Child.prototype = <span class="built_in">Object</span>.creat(Parent.prototype);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 法二的原理：创建一个中转对象，使该对象的__proto__指向父类原型，constructor指向子类构造器</span></span><br><span class="line"><span class="comment">    function creat(parentPrototype)&#123;</span></span><br><span class="line"><span class="comment">        let Fn = function()&#123;&#125;;</span></span><br><span class="line"><span class="comment">        Fn.prototype = parentPrototype;</span></span><br><span class="line"><span class="comment">        return new Fn();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">注：法二会带来一个问题，中转对象并没有<span class="keyword">constructor</span>指针，因此Child的实例在访问<span class="keyword">constructor</span>的时候，最终所指向是父类原型上的<span class="keyword">constructor</span>的指向，即为Parent函数！</span><br><span class="line"></span><br><span class="line">如何纠正<span class="keyword">constructor</span>指向：</span><br><span class="line">a. Child.prototype = Object.creat(Parent.prototype, &#123;</span><br><span class="line">    <span class="keyword">constructor</span>:&#123;value:Child&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 自己实现一个Objec.create函数</span></span><br><span class="line">b. function create(parentPrototype, props)&#123;</span><br><span class="line">        <span class="keyword">let</span> Fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">        Fn.prototype = parentPrototype;</span><br><span class="line">        <span class="keyword">let</span> fn = <span class="keyword">new</span> Fn(); <span class="comment">// fn的__proto__已经指向了parentPrototype</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> props)&#123;</span><br><span class="line">            <span class="built_in">Object</span>.defineProperty(fn, key, &#123;</span><br><span class="line">                  ...props[key],</span><br><span class="line">                  enumberable:<span class="literal">true</span>,<span class="comment">// 表示是否可以被枚举（默认false）</span></span><br><span class="line">            <span class="comment">//    configurable:true, // 表示是否可以被删除(默认true)</span></span><br><span class="line">            <span class="comment">//    writable:true, // 是否可被修改</span></span><br><span class="line">            <span class="comment">//    value: 1, // 值</span></span><br><span class="line">            <span class="comment">// 注意：get/set 不能与writable和valu一起使用</span></span><br><span class="line">            <span class="comment">//    get()&#123;&#125;,</span></span><br><span class="line">            <span class="comment">//    set()&#123;&#125;</span></span><br><span class="line">            &#125;);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 也可以使用fn[key]=props[key]; 只是此时，传递的参数要改为&#123;constructor:Child&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fn;</span><br><span class="line">    &#125;</span><br><span class="line">eg: </span><br><span class="line">Child.prototype = creat(Parent.prototype, &#123;<span class="attr">constructor</span>:&#123;<span class="attr">value</span>:Child&#125;&#125;); <span class="comment">// 注意：constructor的值是一个以value为key的对象</span></span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="built_in">console</span>.log(child.constructor);</span><br><span class="line"></span><br><span class="line">parent.__proto__.eat 和 parent.eat 区别：</span><br><span class="line">二者都能找到原型上的eat方法，区别在于前者会直接在原型上面查找eat方法，后者先会查找实例上的方法有没有eat，没有的话会继续往原型上找。</span><br></pre></td></tr></table></figure>
<p>补充：</p>
<p>法一的继承图示：<br><img src="/2019/01/16/JavaScript进阶/关于继承/WEBRESOURCE676677f0d2c717f1013e97e3e0c62ff7" alt="screenshot from 2018-10-24 15-41-24.png"></p>
<p>法二的继承图示：</p>
<p><code>红色的线代表初始状态</code>，<code>紫色的线代表继承状态</code>，<code>浅蓝色的线代表构造器指示状态</code><br><img src="/2019/01/16/JavaScript进阶/关于继承/WEBRESOURCE1ab27e9510f919f9f4b87919e7f73cf8" alt="creat方法"></p>
<h5 id="继承公有属性和私有属性（一般不使用）："><a href="#继承公有属性和私有属性（一般不使用）：" class="headerlink" title="继承公有属性和私有属性（一般不使用）："></a>继承公有属性和私有属性（一般不使用）：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">核心思想：让子类的原型等于父类的实例，这样就能访问到父类实例上的属性和原型上的属性；也需要修正constructor；</span><br><span class="line">Child.prototype = new Parent();</span><br></pre></td></tr></table></figure>
<h4 id="注：函数声明和函数表达式的一个区别"><a href="#注：函数声明和函数表达式的一个区别" class="headerlink" title="注：函数声明和函数表达式的一个区别"></a>注：函数声明和函数表达式的一个区别</h4><ul>
<li><p>function a(){}</p>
<blockquote>
<p>此时，可以通过a获取该函数的引用</p>
</blockquote>
</li>
<li><p>let aa = function b(){}</p>
<blockquote>
<p>此后，可以在函数外部通过aa获得函数的引用，但不能通过b获得,<br>  <strong>但是</strong>可以在函数内部通过b获得函数的引用。</p>
</blockquote>
</li>
</ul>
<h3 id="ES6，class的继承-继承全部属性：私有、公有、静态"><a href="#ES6，class的继承-继承全部属性：私有、公有、静态" class="headerlink" title="ES6，class的继承(继承全部属性：私有、公有、静态)"></a>ES6，class的继承(继承全部属性：私有、公有、静态)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Parent&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.name = &apos;parent&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    eat()&#123;</span><br><span class="line">        console.log(&apos;eat&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Child extends Parent&#123;</span><br><span class="line">    static aa = 1; // 静态属性（ES7支持）</span><br><span class="line">    </span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.age = 9; // 私有属性</span><br><span class="line">    &#125;</span><br><span class="line">    smoking()&#123; // 原型上的方法</span><br><span class="line">        console.log(&apos;smoking&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    static a()&#123; // 属于类上的方法</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="关于Object-create"><a href="#关于Object-create" class="headerlink" title="关于Object.create()"></a>关于Object.create()</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使子类原型（就是个普通对象）的__proto__指向父类原型</span></span><br><span class="line"><span class="comment">// prototype也好__proto__也好，都是一个引用（指针）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">creat</span>(<span class="params">parentProto</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 从这里可以看到，creat生产的（中间）普通对象的__proto__指向父类原型，因此，子类生产的实例所调用的constructor为父类的prototype中的constructor，即指向父类构造函数。</span></span><br><span class="line">    F.prototype = parentProto;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">B.prototype = creat(A.prototype);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br><span class="line"><span class="comment">// 指向父类构造函数</span></span><br><span class="line"><span class="built_in">console</span>.log(b.constructor); <span class="comment">// [Function: A]</span></span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote>
<p>其实，说了这么多，关于公有属性的继承，即基于原型链的继承，他的目的就是：使子类构造函数的原型对象的<strong>proto</strong>属性指向父类的原型对象。</p>
</blockquote>
<blockquote>
<p>因此，要修改子类原型对象的constructor指向</p>
</blockquote>
<p>关于create函数的实现，之所以使用一个构造函数F来产生一个对象，而不是直接使用一个空对象，主要原因还是因为要避开直接操作<strong>proto</strong>属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">parentProto</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> proto = &#123;&#125;;</span><br><span class="line">    proto.__proto__ = parentProto;</span><br><span class="line">    <span class="keyword">return</span> proto;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">其实完全等价于：</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">parentProto</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">    F.prototype = parentProto;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">也等价于：</span><br><span class="line">Child.prototype.__proto__ = Parent.prototype;</span><br><span class="line"></span><br><span class="line">也等价于：</span><br><span class="line">Child.prototype = <span class="built_in">Object</span>.setPrototypeOf(Child.prototype, Parent.prototype)</span><br></pre></td></tr></table></figure>
<h4 id="关于new操作符和继承"><a href="#关于new操作符和继承" class="headerlink" title="关于new操作符和继承"></a>关于new操作符和继承</h4><blockquote>
<p>new内部一定使用了原型机制</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">对一个构造函数F执行<span class="keyword">new</span>的时候，会发生以下动作：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> <span class="keyword">let</span> proto = <span class="built_in">Object</span>.create(F.prototype); <span class="comment">// 接触该构造函数的原型链</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> <span class="keyword">let</span> res = F.apply(proto, <span class="built_in">arguments</span>); <span class="comment">// 挂载私有属性, 注意！构造函数可能有显式返回值，没有的话默认返回this</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 忽略构造函数返回的基本类型值，若返回object类型，则使用它</span></span><br><span class="line"><span class="number">3.</span> <span class="keyword">return</span> (<span class="keyword">typeof</span> res === <span class="string">'object'</span>) &amp;&amp; res || proto;</span><br></pre></td></tr></table></figure></div><div class="tags"><a href="/tags/JavaScript核心/">JavaScript核心</a></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/2019/01/16/JavaScript进阶/typescript的变量定义/" class="pre">typescript的变量定义</a><a href="/2019/01/16/JavaScript进阶/函数作用域确定/" class="next">函数作用域确定</a></div><div id="comments"><div id="SOHUCS" sid="2019/01/16/JavaScript进阶/关于继承/"></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-5"><a class="toc-link" href="#类的继承按照功能划分为：继承类的私有属性、继承类的公有属性、继承类的静态属性"><span class="toc-text">类的继承按照功能划分为：继承类的私有属性、继承类的公有属性、继承类的静态属性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ES5的继承："><span class="toc-text">ES5的继承：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#私有属性的继承："><span class="toc-text">私有属性的继承：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#公有属性的继承：-目的：访问到父类原型上的属性，即-使-子类原型-Child-prototype-的proto指向父类原型"><span class="toc-text">公有属性的继承：(目的：访问到父类原型上的属性，即: 使 子类原型(Child.prototype) 的proto指向父类原型)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#继承公有属性和私有属性（一般不使用）："><span class="toc-text">继承公有属性和私有属性（一般不使用）：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#注：函数声明和函数表达式的一个区别"><span class="toc-text">注：函数声明和函数表达式的一个区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ES6，class的继承-继承全部属性：私有、公有、静态"><span class="toc-text">ES6，class的继承(继承全部属性：私有、公有、静态)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#关于Object-create"><span class="toc-text">关于Object.create()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#关于new操作符和继承"><span class="toc-text">关于new操作符和继承</span></a></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/02/23/golang/golang基础/">golang基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/23/杂项/Git常用操作/">Git 常用操作</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/01/React相关/React新特性/">react新特性</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/20/JavaScript进阶/如何监听div的高宽改变/">如何监听div的高宽改变</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/20/React相关/为什么使用immutable.js/">为什么使用immutable.js（不可变）？</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/20/React相关/从createStore和applyMiddleWare看redux 中间件的原理/">从createStore和applyMiddleWare看redux 中间件的原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/20/React相关/react视图更新过程/">react视图更新过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/14/CSS/深入理解css权重/">深入理解css权重</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/14/JavaScript基础/不能使用箭头函数的场景/">不能使用箭头函数的场景</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/14/JavaScript基础/从输入url到页面展现发生了什么/">从输入url到页面展现发生了什么</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/ES6/">ES6</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a><span class="category-list-count">44</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript基础/">JavaScript基础</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/React/">React</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/React相关/">React相关</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/css/">css</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/go/">go</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/http/">http</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/javascript进阶/">javascript进阶</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂项/">杂项</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/框架相关/">框架相关</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/css常用/" style="font-size: 15px;">css常用</a> <a href="/tags/css权重/" style="font-size: 15px;">css权重</a> <a href="/tags/ES6，ES7新特性/" style="font-size: 15px;">ES6，ES7新特性</a> <a href="/tags/Spring详解/" style="font-size: 15px;">Spring详解</a> <a href="/tags/JavaScript核心/" style="font-size: 15px;">JavaScript核心</a> <a href="/tags/JavaScript基础/" style="font-size: 15px;">JavaScript基础</a> <a href="/tags/JavaScript进阶/" style="font-size: 15px;">JavaScript进阶</a> <a href="/tags/监听元素高宽/" style="font-size: 15px;">监听元素高宽</a> <a href="/tags/react/" style="font-size: 15px;">react</a> <a href="/tags/redux/" style="font-size: 15px;">redux</a> <a href="/tags/golang基础/" style="font-size: 15px;">golang基础</a> <a href="/tags/http、https/" style="font-size: 15px;">http、https</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/Git/" style="font-size: 15px;">Git</a> <a href="/tags/nginx/" style="font-size: 15px;">nginx</a> <a href="/tags/分布式/" style="font-size: 15px;">分布式</a> <a href="/tags/npm基础/" style="font-size: 15px;">npm基础</a> <a href="/tags/webpack/" style="font-size: 15px;">webpack</a> <a href="/tags/性能优化/" style="font-size: 15px;">性能优化</a> <a href="/tags/react原理/" style="font-size: 15px;">react原理</a> <a href="/tags/框架比较/" style="font-size: 15px;">框架比较</a> <a href="/tags/移动端/" style="font-size: 15px;">移动端</a> <a href="/tags/排序/" style="font-size: 15px;">排序</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://www.google.com/" title="谷歌" target="_blank">谷歌</a><ul></ul><a href="https://www.baidu.com/" title="百度" target="_blank">百度</a><ul></ul><a href="https://docschina.org/" title="印象中文" target="_blank">印象中文</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p></p><span>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i> 次</i></span><span>|</span><span>Copyright &copy;<a href="/." rel="nofollow">木丁夕雨何.</a></span></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?281cc941ca205b4ebca856d71ae45a55";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script><script>window._config = { showScore: true };
(function(){ 
  var appid = 'cytF5aDWy'; 
  var conf = 'prod_0650efe38e465b0e4820ce8d9c386815'; 
  var width = window.innerWidth || document.documentElement.clientWidth; 
  var nodes =document.getElementsByTagName("head")[0]||document.head||document.documentElement;
  if (/(Android|iPhone|iPad|iPod|iOS)/i.test(navigator.userAgent) && width < 750) {  
      window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>');
  }
  else { 
    var loadJs=function(d,a){
      var b=document.createElement("script");b.setAttribute("type","text/javascript");
      b.setAttribute("charset","UTF-8");
      b.setAttribute("src",d);
      if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}
      nodes.appendChild(b)
    };
    loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); 
  } 
  var loadCss = function(cssString){  
    var style=document.createElement("style");  
    style.setAttribute("type", "text/css");  
    if(style.styleSheet){// IE  
        style.styleSheet.cssText = cssString;  
    } else {// w3c  
        var cssText = document.createTextNode(cssString);  
        style.appendChild(cssText);  
    }
    nodes.appendChild(style);
  }
  window.onload=function(){loadCss('.module-hot-topic,.module-cmt-float-bar{display:none!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .cbox-prompt-w span.prompt-empty-w,#SOHUCS #SOHU_MAIN .module-cmt-float-bar .wrap-cont-w .cont-form-w .form-text-w span.text-null,#SOHUCS #SOHU_MAIN .module-cmt-float-bar .wrap-cont-w .cont-minwidth-w div.cont-comment-w a.comment-link-w,#SOHUCS #SOHU_MAIN .module-cmt-float-bar .wrap-cont-w .cont-minwidth-w div.cont-comment-w span.comment-text-w,#SOHUCS #SOHU_MAIN .module-cmt-footer .section-service-w div.service-wrap-w a:hover,#SOHUCS #SOHU_MAIN .module-cmt-header .section-cbox-w .block-head-w div.header-login,#SOHUCS #SOHU_MAIN .module-cmt-header .section-title-w .title-user-w .user-wrap-w span.wrap-name-w,#SOHUCS #SOHU_MAIN .module-cmt-list .action-click-gw span.click-disable-eg a em.icon-name-bg,#SOHUCS #SOHU_MAIN .module-cmt-list .block-title-gw ul li div.title-name-gw,#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .cmt-list-number .comment-number span.cy-number,#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .cmt-list-number span.comment-number,#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .type-lists li.active,#SOHUCS #SOHU_MAIN .module-cmt-list .msg-wrap-gw .wrap-action-gw .action-click-gw span a:hover,#SOHUCS #SOHU_MAIN .module-cmt-list .picture-box-gw div.box-action-gw a:hover,#SOHUCS #SOHU_MAIN .module-cmt-list .wrap-action-gw .action-click-gw span a:hover em.icon-name-bg,#SOHUCS #SOHU_MAIN .module-cmt-list .wrap-user-gw span.user-name-gw a{color:#40759b!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .post-wrap-border-t div.post-wrap-border-t-r,#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w div.post-wrap-border-l,#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w div.post-wrap-border-r{display:none!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .post-wrap-border-t div.post-wrap-border-t-l{background:#FFF!important;top:-2px!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .action-function-w .uploading-wrapper-dw div.wrapper-image-dw,#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w div.post-wrap-main,#SOHUCS #SOHU_MAIN .module-cmt-float-bar .wrap-cont-w .cont-form-w div.form-text-w,#SOHUCS #SOHU_MAIN .module-cmt-header .section-cbox-w .block-head-w div.header-login,#SOHUCS #SOHU_MAIN .module-cmt-list .module-cmt-box .post-wrap-w div.post-wrap-main{border:1px solid #e6e6e6!important;border-radius:20px 20px 20px 20px;margin:0!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .action-issue-w .issue-btn-w a .btn-fw{width:130px!important;height:34px!important;line-height:33px!important;font-size:17px!important;background:#5483b1!important;border-radius:20px!important;color:#FFF!important;-webkit-box-shadow:0 -1px 4px #5483b1 inset;box-shadow:0 -1px 10px #5483b1 inset}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .action-issue-w .issue-btn-w a .btn-fw:before{content:"发表评论"}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .action-issue-w .issue-btn-w a:hover .btn-fw{color:#40759b!important;background:#FFF!important}#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .type-lists li{background:none!important;border-bottom:1px solid #e6e6e6}#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .type-lists li.active{border:1px solid #e6e6e6;border-radius:10px 10px 0 0;border-bottom:none}#SOHUCS #SOHU_MAIN .module-cmt-list .block-title-gw ul li .title-name-gw div.title-name-gw-tag{background:#5483b1!important;border-radius:3px}#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type div.cmt-list-border{background-color:#e6e6e6!important}#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item{border:1px solid #e6e6e6!important}#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item .nt-logo{text-align:center;line-height:40px;border-radius:50%!important;background:#e6e6e6!important}#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item .nt-logo:before{content:"畅";font-size:22px;color:#FFF}#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item a.nt-text,#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item a.nt-text i{color:#5483b1!important}#SOHUCS #SOHU_MAIN .module-cmt-header .section-title-w .title-user-w .user-wrap-w{background:#FFF!important}');};
})();</script><script src="https://assets.changyan.sohu.com/upload/plugins/plugins.count.js"></script></body></html>